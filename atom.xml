<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jerilee.github.io</id>
    <title>Rong Sir的博客</title>
    <updated>2020-07-22T15:56:53.592Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jerilee.github.io"/>
    <link rel="self" href="https://jerilee.github.io/atom.xml"/>
    <subtitle>Phone: 17621996523
Mail: Rongerace@163.com</subtitle>
    <logo>https://jerilee.github.io/images/avatar.png</logo>
    <icon>https://jerilee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Rong Sir的博客</rights>
    <entry>
        <title type="html"><![CDATA[代码模板（敏感词匹配）]]></title>
        <id>https://jerilee.github.io/post/dai-ma-mo-ban-min-gan-ci-pi-pei/</id>
        <link href="https://jerilee.github.io/post/dai-ma-mo-ban-min-gan-ci-pi-pei/">
        </link>
        <updated>2020-07-22T15:47:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="敏感词匹配算法">敏感词匹配算法，</h2>
<h2 id="基于字典树">基于字典树</h2>
<p>最基础敏感词匹配，对于敏感词大多在3-5个之间，效率非常高，测试效率比大多数网上的模板都要高很多。</p>
<h3 id="c版本">C#版本</h3>
<pre><code class="language-C#"> // Author : JeriLee
  // Time : 2020-7-18-11:01
  public class Trie {
    public sealed class TrieNode {
      public bool vis;
      public Dictionary&lt;char ,TrieNode&gt; nextNode;

      public TrieNode() {
        nextNode = new Dictionary&lt;char, TrieNode&gt;();
        vis = false;
      }

      public bool TryGetValue(char c, out TrieNode node) {
        return nextNode.TryGetValue(c, out node);
      }

      public TrieNode GetNextNode(char c) {
        if (!nextNode.TryGetValue(c, out TrieNode node)) {
          node = new TrieNode();
          nextNode[c] = node;
        }
        return node;
      }
    }

    const string simplify = &quot;锕皑蔼碍爱嗳嫒瑷暧霭谙铵鹌肮袄奥媪骜鳌坝罢钯摆败呗颁办绊钣帮绑镑谤剥饱宝报鲍鸨龅辈贝钡狈备惫鹎贲锛绷笔毕毙币闭荜哔滗铋筚跸边编贬变辩辫苄缏笾标骠飑飙镖镳鳔鳖别瘪濒滨宾摈傧缤槟殡膑镔髌鬓饼禀拨钵铂驳饽钹鹁补钸财参蚕残惭惨灿骖黪苍舱仓沧厕侧册测恻层诧锸侪钗搀掺蝉馋谗缠铲产阐颤冁谄谶蒇忏婵骣觇禅镡场尝长偿肠厂畅伥苌怅阊鲳钞车彻砗尘陈衬伧谌榇碜龀撑称惩诚骋枨柽铖铛痴迟驰耻齿炽饬鸱冲冲虫宠铳畴踌筹绸俦帱雠橱厨锄雏础储触处刍绌蹰传钏疮闯创怆锤缍纯鹑绰辍龊辞词赐鹚聪葱囱从丛苁骢枞凑辏蹿窜撺错锉鹾达哒鞑带贷骀绐担单郸掸胆惮诞弹殚赕瘅箪当挡党荡档谠砀裆捣岛祷导盗焘灯邓镫敌涤递缔籴诋谛绨觌镝颠点垫电巅钿癫钓调铫鲷谍叠鲽钉顶锭订铤丢铥东动栋冻岽鸫窦犊独读赌镀渎椟牍笃黩锻断缎簖兑队对怼镦吨顿钝炖趸夺堕铎鹅额讹恶饿谔垩阏轭锇锷鹗颚颛鳄诶儿尔饵贰迩铒鸸鲕发罚阀珐矾钒烦贩饭访纺钫鲂飞诽废费绯镄鲱纷坟奋愤粪偾丰枫锋风疯冯缝讽凤沣肤辐抚辅赋复负讣妇缚凫驸绂绋赙麸鲋鳆钆该钙盖赅杆赶秆赣尴擀绀冈刚钢纲岗戆镐睾诰缟锆搁鸽阁铬个纥镉颍给亘赓绠鲠龚宫巩贡钩沟苟构购够诟缑觏蛊顾诂毂钴锢鸪鹄鹘剐挂鸹掴关观馆惯贯诖掼鹳鳏广犷规归龟闺轨诡贵刽匦刿妫桧鲑鳜辊滚衮绲鲧锅国过埚呙帼椁蝈铪骇韩汉阚绗颉号灏颢阂鹤贺诃阖蛎横轰鸿红黉讧荭闳鲎壶护沪户浒鹕哗华画划话骅桦铧怀坏欢环还缓换唤痪焕涣奂缳锾鲩黄谎鳇挥辉毁贿秽会烩汇讳诲绘诙荟哕浍缋珲晖荤浑诨馄阍获货祸钬镬击机积饥迹讥鸡绩缉极辑级挤几蓟剂济计记际继纪讦诘荠叽哜骥玑觊齑矶羁虿跻霁鲚鲫夹荚颊贾钾价驾郏浃铗镓蛲歼监坚笺间艰缄茧检碱硷拣捡简俭减荐槛鉴践贱见键舰剑饯渐溅涧谏缣戋戬睑鹣笕鲣鞯将浆蒋桨奖讲酱绛缰胶浇骄娇搅铰矫侥脚饺缴绞轿较挢峤鹪鲛阶节洁结诫届疖颌鲒紧锦仅谨进晋烬尽劲荆茎卺荩馑缙赆觐鲸惊经颈静镜径痉竞净刭泾迳弪胫靓纠厩旧阄鸠鹫驹举据锯惧剧讵屦榉飓钜锔窭龃鹃绢锩镌隽觉决绝谲珏钧军骏皲开凯剀垲忾恺铠锴龛闶钪铐颗壳课骒缂轲钶锞颔垦恳龈铿抠库裤喾块侩郐哙脍宽狯髋矿旷况诓诳邝圹纩贶亏岿窥馈溃匮蒉愦聩篑阃锟鲲扩阔蛴蜡腊莱来赖崃徕涞濑赉睐铼癞籁蓝栏拦篮阑兰澜谰揽览懒缆烂滥岚榄斓镧褴琅阆锒捞劳涝唠崂铑铹痨乐鳓镭垒类泪诔缧篱狸离鲤礼丽厉励砾历沥隶俪郦坜苈莅蓠呖逦骊缡枥栎轹砺锂鹂疠粝跞雳鲡鳢俩联莲连镰怜涟帘敛脸链恋炼练蔹奁潋琏殓裢裣鲢粮凉两辆谅魉疗辽镣缭钌鹩猎临邻鳞凛赁蔺廪檩辚躏龄铃灵岭领绫棂蛏鲮馏刘浏骝绺镏鹨龙聋咙笼垄拢陇茏泷珑栊胧砻楼娄搂篓偻蒌喽嵝镂瘘耧蝼髅芦卢颅庐炉掳卤虏鲁赂禄录陆垆撸噜闾泸渌栌橹轳辂辘氇胪鸬鹭舻鲈峦挛孪滦乱脔娈栾鸾銮抡轮伦仑沦纶论囵萝罗逻锣箩骡骆络荦猡泺椤脶镙驴吕铝侣屡缕虑滤绿榈褛锊呒妈玛码蚂马骂吗唛嬷杩买麦卖迈脉劢瞒馒蛮满谩缦镘颡鳗猫锚铆贸麽没镁门闷们扪焖懑钔锰梦眯谜弥觅幂芈谧猕祢绵缅渑腼黾庙缈缪灭悯闽闵缗鸣铭谬谟蓦馍殁镆谋亩钼呐钠纳难挠脑恼闹铙讷馁内拟腻铌鲵撵辇鲶酿鸟茑袅聂啮镊镍陧蘖嗫颟蹑柠狞宁拧泞苎咛聍钮纽脓浓农侬哝驽钕诺傩疟欧鸥殴呕沤讴怄瓯盘蹒庞抛疱赔辔喷鹏纰罴铍骗谝骈飘缥频贫嫔苹凭评泼颇钋扑铺朴谱镤镨栖脐齐骑岂启气弃讫蕲骐绮桤碛颀颃鳍牵钎铅迁签谦钱钳潜浅谴堑佥荨悭骞缱椠钤枪呛墙蔷强抢嫱樯戗炝锖锵镪羟跄锹桥乔侨翘窍诮谯荞缲硗跷窃惬锲箧钦亲寝锓轻氢倾顷请庆揿鲭琼穷茕蛱巯赇虮鳅趋区躯驱龋诎岖阒觑鸲颧权劝诠绻辁铨却鹊确阕阙悫让饶扰绕荛娆桡热韧认纫饪轫荣绒嵘蝾缛铷颦软锐蚬闰润洒萨飒鳃赛伞毵糁丧骚扫缫涩啬铯穑杀刹纱铩鲨筛晒酾删闪陕赡缮讪姗骟钐鳝墒伤赏垧殇觞烧绍赊摄慑设厍滠畲绅审婶肾渗诜谂渖声绳胜师狮湿诗时蚀实识驶势适释饰视试谥埘莳弑轼贳铈鲥寿兽绶枢输书赎属术树竖数摅纾帅闩双谁税顺说硕烁铄丝饲厮驷缌锶鸶耸怂颂讼诵擞薮馊飕锼苏诉肃谡稣虽随绥岁谇孙损笋荪狲缩琐锁唢睃獭挞闼铊鳎台态钛鲐摊贪瘫滩坛谭谈叹昙钽锬顸汤烫傥饧铴镗涛绦讨韬铽腾誊锑题体屉缇鹈阗条粜龆鲦贴铁厅听烃铜统恸头钭秃图钍团抟颓蜕饨脱鸵驮驼椭箨鼍袜娲腽弯湾顽万纨绾网辋韦违围为潍维苇伟伪纬谓卫诿帏闱沩涠玮韪炜鲔温闻纹稳问阌瓮挝蜗涡窝卧莴龌呜钨乌诬无芜吴坞雾务误邬庑怃妩骛鹉鹜锡牺袭习铣戏细饩阋玺觋虾辖峡侠狭厦吓硖鲜纤贤衔闲显险现献县馅羡宪线苋莶藓岘猃娴鹇痫蚝籼跹厢镶乡详响项芗饷骧缃飨萧嚣销晓啸哓潇骁绡枭箫协挟携胁谐写泻谢亵撷绁缬锌衅兴陉荥凶汹锈绣馐鸺虚嘘须许叙绪续诩顼轩悬选癣绚谖铉镟学谑泶鳕勋询寻驯训讯逊埙浔鲟压鸦鸭哑亚讶垭娅桠氩阉烟盐严岩颜阎艳厌砚彦谚验厣赝俨兖谳恹闫酽魇餍鼹鸯杨扬疡阳痒养样炀瑶摇尧遥窑谣药轺鹞鳐爷页业叶靥谒邺晔烨医铱颐遗仪蚁艺亿忆义诣议谊译异绎诒呓峄饴怿驿缢轶贻钇镒镱瘗舣荫阴银饮隐铟瘾樱婴鹰应缨莹萤营荧蝇赢颖茔莺萦蓥撄嘤滢潆璎鹦瘿颏罂哟拥佣痈踊咏镛优忧邮铀犹诱莸铕鱿舆鱼渔娱与屿语狱誉预驭伛俣谀谕蓣嵛饫阈妪纡觎欤钰鹆鹬龉鸳渊辕园员圆缘远橼鸢鼋约跃钥粤悦阅钺郧匀陨运蕴酝晕韵郓芸恽愠纭韫殒氲杂灾载攒暂赞瓒趱錾赃脏驵凿枣责择则泽赜啧帻箦贼谮赠综缯轧铡闸栅诈斋债毡盏斩辗崭栈战绽谵张涨帐账胀赵诏钊蛰辙锗这谪辄鹧贞针侦诊镇阵浈缜桢轸赈祯鸩挣睁狰争帧症郑证诤峥钲铮筝织职执纸挚掷帜质滞骘栉栀轵轾贽鸷蛳絷踬踯觯钟终种肿众锺诌轴皱昼骤纣绉猪诸诛烛瞩嘱贮铸驻伫槠铢专砖转赚啭馔颞桩庄装妆壮状锥赘坠缀骓缒谆准着浊诼镯兹资渍谘缁辎赀眦锱龇鲻踪总纵偬邹诹驺鲰诅组镞钻缵躜鳟翱并卜沉丑淀迭斗范干皋硅柜后伙秸杰诀夸里凌么霉捻凄扦圣尸抬涂洼喂污锨咸蝎彝涌游吁御愿岳云灶扎札筑于志注凋讠谫郄勐凼坂垅垴埯埝苘荬荮莜莼菰藁揸吒吣咔咝咴噘噼嚯幞岙嵴彷徼犸狍馀馇馓馕愣憷懔丬溆滟溷漤潴澹甯纟绔绱珉枧桊桉槔橥轱轷赍肷胨飚煳煅熘愍淼砜磙眍钚钷铘铞锃锍锎锏锘锝锪锫锿镅镎镢镥镩镲稆鹋鹛鹱疬疴痖癯裥襁耢颥螨麴鲅鲆鲇鲞鲴鲺鲼鳊鳋鳘鳙鞒鞴齄&quot;;
    const string traditional = &quot;錒皚藹礙愛噯嬡璦曖靄諳銨鵪骯襖奧媼驁鰲壩罷鈀擺敗唄頒辦絆鈑幫綁鎊謗剝飽寶報鮑鴇齙輩貝鋇狽備憊鵯賁錛繃筆畢斃幣閉蓽嗶潷鉍篳蹕邊編貶變辯辮芐緶籩標驃颮飆鏢鑣鰾鱉別癟瀕濱賓擯儐繽檳殯臏鑌髕鬢餅稟撥缽鉑駁餑鈸鵓補鈽財參蠶殘慚慘燦驂黲蒼艙倉滄廁側冊測惻層詫鍤儕釵攙摻蟬饞讒纏鏟產闡顫囅諂讖蕆懺嬋驏覘禪鐔場嘗長償腸廠暢倀萇悵閶鯧鈔車徹硨塵陳襯傖諶櫬磣齔撐稱懲誠騁棖檉鋮鐺癡遲馳恥齒熾飭鴟沖衝蟲寵銃疇躊籌綢儔幬讎櫥廚鋤雛礎儲觸處芻絀躕傳釧瘡闖創愴錘綞純鶉綽輟齪辭詞賜鶿聰蔥囪從叢蓯驄樅湊輳躥竄攛錯銼鹺達噠韃帶貸駘紿擔單鄲撣膽憚誕彈殫賧癉簞當擋黨蕩檔讜碭襠搗島禱導盜燾燈鄧鐙敵滌遞締糴詆諦綈覿鏑顛點墊電巔鈿癲釣調銚鯛諜疊鰈釘頂錠訂鋌丟銩東動棟凍崠鶇竇犢獨讀賭鍍瀆櫝牘篤黷鍛斷緞籪兌隊對懟鐓噸頓鈍燉躉奪墮鐸鵝額訛惡餓諤堊閼軛鋨鍔鶚顎顓鱷誒兒爾餌貳邇鉺鴯鮞發罰閥琺礬釩煩販飯訪紡鈁魴飛誹廢費緋鐨鯡紛墳奮憤糞僨豐楓鋒風瘋馮縫諷鳳灃膚輻撫輔賦復負訃婦縛鳧駙紱紼賻麩鮒鰒釓該鈣蓋賅桿趕稈贛尷搟紺岡剛鋼綱崗戇鎬睪誥縞鋯擱鴿閣鉻個紇鎘潁給亙賡綆鯁龔宮鞏貢鉤溝茍構購夠詬緱覯蠱顧詁轂鈷錮鴣鵠鶻剮掛鴰摑關觀館慣貫詿摜鸛鰥廣獷規歸龜閨軌詭貴劊匭劌媯檜鮭鱖輥滾袞緄鯀鍋國過堝咼幗槨蟈鉿駭韓漢闞絎頡號灝顥閡鶴賀訶闔蠣橫轟鴻紅黌訌葒閎鱟壺護滬戶滸鶘嘩華畫劃話驊樺鏵懷壞歡環還緩換喚瘓煥渙奐繯鍰鯇黃謊鰉揮輝毀賄穢會燴匯諱誨繪詼薈噦澮繢琿暉葷渾諢餛閽獲貨禍鈥鑊擊機積饑跡譏雞績緝極輯級擠幾薊劑濟計記際繼紀訐詰薺嘰嚌驥璣覬齏磯羈蠆躋霽鱭鯽夾莢頰賈鉀價駕郟浹鋏鎵蟯殲監堅箋間艱緘繭檢堿鹼揀撿簡儉減薦檻鑒踐賤見鍵艦劍餞漸濺澗諫縑戔戩瞼鶼筧鰹韉將漿蔣槳獎講醬絳韁膠澆驕嬌攪鉸矯僥腳餃繳絞轎較撟嶠鷦鮫階節潔結誡屆癤頜鮚緊錦僅謹進晉燼盡勁荊莖巹藎饉縉贐覲鯨驚經頸靜鏡徑痙競凈剄涇逕弳脛靚糾廄舊鬮鳩鷲駒舉據鋸懼劇詎屨櫸颶鉅鋦窶齟鵑絹錈鐫雋覺決絕譎玨鈞軍駿皸開凱剴塏愾愷鎧鍇龕閌鈧銬顆殼課騍緙軻鈳錁頷墾懇齦鏗摳庫褲嚳塊儈鄶噲膾寬獪髖礦曠況誆誑鄺壙纊貺虧巋窺饋潰匱蕢憒聵簣閫錕鯤擴闊蠐蠟臘萊來賴崍徠淶瀨賚睞錸癩籟藍欄攔籃闌蘭瀾讕攬覽懶纜爛濫嵐欖斕鑭襤瑯閬鋃撈勞澇嘮嶗銠鐒癆樂鰳鐳壘類淚誄縲籬貍離鯉禮麗厲勵礫歷瀝隸儷酈壢藶蒞蘺嚦邐驪縭櫪櫟轢礪鋰鸝癘糲躒靂鱺鱧倆聯蓮連鐮憐漣簾斂臉鏈戀煉練蘞奩瀲璉殮褳襝鰱糧涼兩輛諒魎療遼鐐繚釕鷯獵臨鄰鱗凜賃藺廩檁轔躪齡鈴靈嶺領綾欞蟶鯪餾劉瀏騮綹鎦鷚龍聾嚨籠壟攏隴蘢瀧瓏櫳朧礱樓婁摟簍僂蔞嘍嶁鏤瘺耬螻髏蘆盧顱廬爐擄鹵虜魯賂祿錄陸壚擼嚕閭瀘淥櫨櫓轤輅轆氌臚鸕鷺艫鱸巒攣孿灤亂臠孌欒鸞鑾掄輪倫侖淪綸論圇蘿羅邏鑼籮騾駱絡犖玀濼欏腡鏍驢呂鋁侶屢縷慮濾綠櫚褸鋝嘸媽瑪碼螞馬罵嗎嘜嬤榪買麥賣邁脈勱瞞饅蠻滿謾縵鏝顙鰻貓錨鉚貿麼沒鎂門悶們捫燜懣鍆錳夢瞇謎彌覓冪羋謐獼禰綿緬澠靦黽廟緲繆滅憫閩閔緡鳴銘謬謨驀饃歿鏌謀畝鉬吶鈉納難撓腦惱鬧鐃訥餒內擬膩鈮鯢攆輦鯰釀鳥蔦裊聶嚙鑷鎳隉蘗囁顢躡檸獰寧擰濘苧嚀聹鈕紐膿濃農儂噥駑釹諾儺瘧歐鷗毆嘔漚謳慪甌盤蹣龐拋皰賠轡噴鵬紕羆鈹騙諞駢飄縹頻貧嬪蘋憑評潑頗釙撲鋪樸譜鏷鐠棲臍齊騎豈啟氣棄訖蘄騏綺榿磧頎頏鰭牽釬鉛遷簽謙錢鉗潛淺譴塹僉蕁慳騫繾槧鈐槍嗆墻薔強搶嬙檣戧熗錆鏘鏹羥蹌鍬橋喬僑翹竅誚譙蕎繰磽蹺竊愜鍥篋欽親寢鋟輕氫傾頃請慶撳鯖瓊窮煢蛺巰賕蟣鰍趨區軀驅齲詘嶇闃覷鴝顴權勸詮綣輇銓卻鵲確闋闕愨讓饒擾繞蕘嬈橈熱韌認紉飪軔榮絨嶸蠑縟銣顰軟銳蜆閏潤灑薩颯鰓賽傘毿糝喪騷掃繅澀嗇銫穡殺剎紗鎩鯊篩曬釃刪閃陜贍繕訕姍騸釤鱔墑傷賞坰殤觴燒紹賒攝懾設厙灄畬紳審嬸腎滲詵諗瀋聲繩勝師獅濕詩時蝕實識駛勢適釋飾視試謚塒蒔弒軾貰鈰鰣壽獸綬樞輸書贖屬術樹豎數攄紓帥閂雙誰稅順說碩爍鑠絲飼廝駟緦鍶鷥聳慫頌訟誦擻藪餿颼鎪蘇訴肅謖穌雖隨綏歲誶孫損筍蓀猻縮瑣鎖嗩脧獺撻闥鉈鰨臺態鈦鮐攤貪癱灘壇譚談嘆曇鉭錟頇湯燙儻餳鐋鏜濤絳討韜鋱騰謄銻題體屜緹鵜闐條糶齠鰷貼鐵廳聽烴銅統慟頭鈄禿圖釷團摶頹蛻飩脫鴕馱駝橢籜鼉襪媧膃彎灣頑萬紈綰網輞韋違圍為濰維葦偉偽緯謂衛諉幃闈溈潿瑋韙煒鮪溫聞紋穩問閿甕撾蝸渦窩臥萵齷嗚鎢烏誣無蕪吳塢霧務誤鄔廡憮嫵騖鵡鶩錫犧襲習銑戲細餼鬩璽覡蝦轄峽俠狹廈嚇硤鮮纖賢銜閑顯險現獻縣餡羨憲線莧薟蘚峴獫嫻鷴癇蠔秈躚廂鑲鄉詳響項薌餉驤緗饗蕭囂銷曉嘯嘵瀟驍綃梟簫協挾攜脅諧寫瀉謝褻擷紲纈鋅釁興陘滎兇洶銹繡饈鵂虛噓須許敘緒續詡頊軒懸選癬絢諼鉉鏇學謔澩鱈勛詢尋馴訓訊遜塤潯鱘壓鴉鴨啞亞訝埡婭椏氬閹煙鹽嚴巖顏閻艷厭硯彥諺驗厴贗儼兗讞懨閆釅魘饜鼴鴦楊揚瘍陽癢養樣煬瑤搖堯遙窯謠藥軺鷂鰩爺頁業葉靨謁鄴曄燁醫銥頤遺儀蟻藝億憶義詣議誼譯異繹詒囈嶧飴懌驛縊軼貽釔鎰鐿瘞艤蔭陰銀飲隱銦癮櫻嬰鷹應纓瑩螢營熒蠅贏穎塋鶯縈鎣攖嚶瀅瀠瓔鸚癭頦罌喲擁傭癰踴詠鏞優憂郵鈾猶誘蕕銪魷輿魚漁娛與嶼語獄譽預馭傴俁諛諭蕷崳飫閾嫗紆覦歟鈺鵒鷸齬鴛淵轅園員圓緣遠櫞鳶黿約躍鑰粵悅閱鉞鄖勻隕運蘊醞暈韻鄆蕓惲慍紜韞殞氳雜災載攢暫贊瓚趲鏨贓臟駔鑿棗責擇則澤賾嘖幘簀賊譖贈綜繒軋鍘閘柵詐齋債氈盞斬輾嶄棧戰綻譫張漲帳賬脹趙詔釗蟄轍鍺這謫輒鷓貞針偵診鎮陣湞縝楨軫賑禎鴆掙睜猙爭幀癥鄭證諍崢鉦錚箏織職執紙摯擲幟質滯騭櫛梔軹輊贄鷙螄縶躓躑觶鐘終種腫眾鍾謅軸皺晝驟紂縐豬諸誅燭矚囑貯鑄駐佇櫧銖專磚轉賺囀饌顳樁莊裝妝壯狀錐贅墜綴騅縋諄準著濁諑鐲茲資漬諮緇輜貲眥錙齜鯔蹤總縱傯鄒諏騶鯫詛組鏃鉆纘躦鱒翺並蔔沈醜澱叠鬥範幹臯矽櫃後夥稭傑訣誇裏淩麽黴撚淒扡聖屍擡塗窪餵汙鍁鹹蠍彜湧遊籲禦願嶽雲竈紮劄築於誌註雕訁譾郤猛氹阪壟堖垵墊檾蕒葤蓧蒓菇槁摣咤唚哢噝噅撅劈謔襆嶴脊仿僥獁麅餘餷饊饢楞怵懍爿漵灩混濫瀦淡寧糸絝緔瑉梘棬案橰櫫軲軤賫膁腖飈糊煆溜湣渺碸滾瞘鈈鉕鋣銱鋥鋶鐦鐧鍩鍀鍃錇鎄鎇鎿鐝鑥鑹鑔穭鶓鶥鸌癧屙瘂臒襇繈耮顬蟎麯鮁鮃鮎鯗鯝鯴鱝鯿鰠鰵鱅鞽韝齇&quot;;

    static char[] TradToSimp = new char[char.MaxValue];

    static char GetSimp(char c) {
      char s = TradToSimp[c];
      return s == '\0' ? c : s;
    }

    public Trie() {
      int len = Math.Min(simplify.Length, traditional.Length);
      for (int i = 0; i &lt; len; i++) {
        TradToSimp[traditional[i]] = simplify[i];
      }
    }

    private TrieNode root_ = new TrieNode();

    public void Init(IEnumerable&lt;string&gt; strs) {
      if(strs != null) {
        foreach (var str in strs) {
          AddModelString(str.Trim());
        }
      }
    }

    public void AddModelString(string str) {
      if(str != null &amp;&amp; str.Length &gt; 0) {
        var thisNode = root_;
        for (int index = 0; index &lt; str.Length;  ++index) {
          char c = GetSimp(str[index]);
          thisNode = thisNode.GetNextNode(c);
        }
        thisNode.vis = true;
      }
    }

    public bool HasKeyWorld(string str, int starIndex, int endIndex) {
      for(int head = starIndex; head &lt; endIndex; ++head) {
        var thisNode = root_;
        for (int index = head; index &lt; endIndex; ++index) {
          if (!thisNode.TryGetValue(GetSimp(str[index]), out var node)) {
            break;
          }
          thisNode = node;
          if (thisNode.vis) return true;
        }
      }

      return false;
    }
  }

</code></pre>
<pre><code class="language-C#">  public class SensetiveWorlds {
    private SensetiveWorlds() {
      trie_ = new Trie();
    }

    public static readonly SensetiveWorlds Instance = new SensetiveWorlds();
    private Trie trie_;
    public void Init(string path) {
      var strs = DocumentReader.ReadFileToList(path);
      trie_.Init(strs);
    }
 
    public bool HasSensitive(string s) {
      return trie_.HasKeyWorld(s, 0, s.Length);
    }
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[本周瞎搞（2020年7月）]]></title>
        <id>https://jerilee.github.io/post/xia-gao-ri-zhi/</id>
        <link href="https://jerilee.github.io/post/xia-gao-ri-zhi/">
        </link>
        <updated>2020-07-22T14:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="发现的微软net-framework库的一个bug">发现的微软.Net FrameWork库的一个BUG，</h2>
<p>2020.7.17</p>
<p>已经把修改提到github地址：<br>
https://github.com/dotnet/runtime/pull/39497<br>
微软工作人员的回应<br>
https://github.com/dotnet/runtime/issues/34472</p>
<p>我阐明了修改的原因：<br>
This &quot;result&quot; is (-2147483647, 0]U[0,2147483648) ,The probability of 0 is twice that of other numbers.<br>
after my modification, the result is (-2147483648, -1] U[0,2147483648), is in all int range.<br>
so after &quot;d += int.maxValue&quot; , d is [0, 2*Int32MaxValue)<br>
so the last code need to do &quot;d /= 2 * (uint)int.MaxValue&quot;</p>
<h2 id="发现c的std库二分查找写法可以再优化一下">发现C++的std库二分查找写法，可以再优化一下</h2>
<p>2020.7.22</p>
<h3 id="c库文档地址">C++库文档地址</h3>
<p>http://en.cppreference.com/w/cpp/algorithm/upper_bound</p>
<h3 id="使用c简单测试了一下">使用C#简单测试了一下</h3>
<pre><code class="language-C#">//库代码
public static int UpperBound&lt;T&gt;(this IList&lt;T&gt; list, int first, int last, Func&lt;T, int&gt; comparer) {
  int count = last - first;
  int it, step;
  while (count &gt; 0) {
    it = first;
    step = count &gt;&gt; 1;
    it += step;
    if (comparer(list[it]) &lt;= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}
//我的代码
public static int MyUpperBound&lt;T&gt;(this IList&lt;T&gt; list, int first, int last, Func&lt;T, int&gt; comparer) {
  int L = first, R = last, mid;
  while (L &lt; R) {
    mid = (L + R) &gt;&gt; 1;
    if (comparer(list[mid]) &lt;= 0 ) {
      L = mid + 1;
    } else {
      R = mid;
    }
  }
  return L;
}
</code></pre>
<h3 id="以下是测试结果便于取时间戳使用的c有时间用c再测一次">以下是测试结果，便于取时间戳，使用的C#，有时间用C++再测一次：</h3>
<figure data-type="image" tabindex="1"><img src="https://jerilee.github.io/post-images/1595426558450.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基础数据结构(字典树 Trie)]]></title>
        <id>https://jerilee.github.io/post/zi-dian-shu-trie/</id>
        <link href="https://jerilee.github.io/post/zi-dian-shu-trie/">
        </link>
        <updated>2020-07-18T01:50:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础数据结构">基础数据结构</h1>
<p>@(数据结构)[字典树|Trie|字符串]</p>
<hr>
<p>[TOC]</p>
<h2 id="字典树-trie"><strong>字典树 Trie</strong></h2>
<p>字典树应用：适合排除敏感词，适合模糊查询<br>
字典树是一颗多叉树，一般采用一个字节大小作为字典树一个节点，即为256叉树。</p>
<h3 id="逻辑实现"><strong>逻辑实现</strong></h3>
<p>例如，现在有敏感词如下：<br>
abc<br>
abd<br>
acd<br>
bda<br>
bef<br>
orz<br>
字典树结构如图，从根节点到每一个叶节点的路径为每个敏感词，比如root-o-r-z这条路径组成&quot;orz&quot;这个字符串<br>
<img src="https://jerilee.github.io/post-images/1595039709938.png" alt="" loading="lazy"></p>
<p>每次查询目标字符串时，从root开始向下匹配字符，时间复杂度O(deep)，deep为字典树深度，空间复杂度无法估算。</p>
<h3 id="code"><strong>Code</strong></h3>
<h4 id="c"><strong>C#</strong></h4>
<h5 id="字典树查询字符串">字典树查询字符串</h5>
<p><strong>最后修改日2020-7-22，采用引用优化版本</strong></p>
<pre><code class="language-C#">   // Author : JeriLee
  // Time : 2020-7-18-11:01
  public class Trie {
    public sealed class TrieNode {
      public bool vis;
      public Dictionary&lt;char ,TrieNode&gt; nextNode;

      public TrieNode() {
        nextNode = new Dictionary&lt;char, TrieNode&gt;();
        vis = false;
      }

      public bool TryGetValue(char c, out TrieNode node) {
        return nextNode.TryGetValue(c, out node);
      }

      public TrieNode GetNextNode(char c) {
        if (!nextNode.TryGetValue(c, out TrieNode node)) {
          node = new TrieNode();
          nextNode[c] = node;
        }
        return node;
      }
    }

    const string simplify = &quot;锕皑蔼碍爱嗳嫒瑷暧霭谙铵鹌肮袄奥媪骜鳌坝罢钯摆败呗颁办绊钣帮绑镑谤剥饱宝报鲍鸨龅辈贝钡狈备惫鹎贲锛绷笔毕毙币闭荜哔滗铋筚跸边编贬变辩辫苄缏笾标骠飑飙镖镳鳔鳖别瘪濒滨宾摈傧缤槟殡膑镔髌鬓饼禀拨钵铂驳饽钹鹁补钸财参蚕残惭惨灿骖黪苍舱仓沧厕侧册测恻层诧锸侪钗搀掺蝉馋谗缠铲产阐颤冁谄谶蒇忏婵骣觇禅镡场尝长偿肠厂畅伥苌怅阊鲳钞车彻砗尘陈衬伧谌榇碜龀撑称惩诚骋枨柽铖铛痴迟驰耻齿炽饬鸱冲冲虫宠铳畴踌筹绸俦帱雠橱厨锄雏础储触处刍绌蹰传钏疮闯创怆锤缍纯鹑绰辍龊辞词赐鹚聪葱囱从丛苁骢枞凑辏蹿窜撺错锉鹾达哒鞑带贷骀绐担单郸掸胆惮诞弹殚赕瘅箪当挡党荡档谠砀裆捣岛祷导盗焘灯邓镫敌涤递缔籴诋谛绨觌镝颠点垫电巅钿癫钓调铫鲷谍叠鲽钉顶锭订铤丢铥东动栋冻岽鸫窦犊独读赌镀渎椟牍笃黩锻断缎簖兑队对怼镦吨顿钝炖趸夺堕铎鹅额讹恶饿谔垩阏轭锇锷鹗颚颛鳄诶儿尔饵贰迩铒鸸鲕发罚阀珐矾钒烦贩饭访纺钫鲂飞诽废费绯镄鲱纷坟奋愤粪偾丰枫锋风疯冯缝讽凤沣肤辐抚辅赋复负讣妇缚凫驸绂绋赙麸鲋鳆钆该钙盖赅杆赶秆赣尴擀绀冈刚钢纲岗戆镐睾诰缟锆搁鸽阁铬个纥镉颍给亘赓绠鲠龚宫巩贡钩沟苟构购够诟缑觏蛊顾诂毂钴锢鸪鹄鹘剐挂鸹掴关观馆惯贯诖掼鹳鳏广犷规归龟闺轨诡贵刽匦刿妫桧鲑鳜辊滚衮绲鲧锅国过埚呙帼椁蝈铪骇韩汉阚绗颉号灏颢阂鹤贺诃阖蛎横轰鸿红黉讧荭闳鲎壶护沪户浒鹕哗华画划话骅桦铧怀坏欢环还缓换唤痪焕涣奂缳锾鲩黄谎鳇挥辉毁贿秽会烩汇讳诲绘诙荟哕浍缋珲晖荤浑诨馄阍获货祸钬镬击机积饥迹讥鸡绩缉极辑级挤几蓟剂济计记际继纪讦诘荠叽哜骥玑觊齑矶羁虿跻霁鲚鲫夹荚颊贾钾价驾郏浃铗镓蛲歼监坚笺间艰缄茧检碱硷拣捡简俭减荐槛鉴践贱见键舰剑饯渐溅涧谏缣戋戬睑鹣笕鲣鞯将浆蒋桨奖讲酱绛缰胶浇骄娇搅铰矫侥脚饺缴绞轿较挢峤鹪鲛阶节洁结诫届疖颌鲒紧锦仅谨进晋烬尽劲荆茎卺荩馑缙赆觐鲸惊经颈静镜径痉竞净刭泾迳弪胫靓纠厩旧阄鸠鹫驹举据锯惧剧讵屦榉飓钜锔窭龃鹃绢锩镌隽觉决绝谲珏钧军骏皲开凯剀垲忾恺铠锴龛闶钪铐颗壳课骒缂轲钶锞颔垦恳龈铿抠库裤喾块侩郐哙脍宽狯髋矿旷况诓诳邝圹纩贶亏岿窥馈溃匮蒉愦聩篑阃锟鲲扩阔蛴蜡腊莱来赖崃徕涞濑赉睐铼癞籁蓝栏拦篮阑兰澜谰揽览懒缆烂滥岚榄斓镧褴琅阆锒捞劳涝唠崂铑铹痨乐鳓镭垒类泪诔缧篱狸离鲤礼丽厉励砾历沥隶俪郦坜苈莅蓠呖逦骊缡枥栎轹砺锂鹂疠粝跞雳鲡鳢俩联莲连镰怜涟帘敛脸链恋炼练蔹奁潋琏殓裢裣鲢粮凉两辆谅魉疗辽镣缭钌鹩猎临邻鳞凛赁蔺廪檩辚躏龄铃灵岭领绫棂蛏鲮馏刘浏骝绺镏鹨龙聋咙笼垄拢陇茏泷珑栊胧砻楼娄搂篓偻蒌喽嵝镂瘘耧蝼髅芦卢颅庐炉掳卤虏鲁赂禄录陆垆撸噜闾泸渌栌橹轳辂辘氇胪鸬鹭舻鲈峦挛孪滦乱脔娈栾鸾銮抡轮伦仑沦纶论囵萝罗逻锣箩骡骆络荦猡泺椤脶镙驴吕铝侣屡缕虑滤绿榈褛锊呒妈玛码蚂马骂吗唛嬷杩买麦卖迈脉劢瞒馒蛮满谩缦镘颡鳗猫锚铆贸麽没镁门闷们扪焖懑钔锰梦眯谜弥觅幂芈谧猕祢绵缅渑腼黾庙缈缪灭悯闽闵缗鸣铭谬谟蓦馍殁镆谋亩钼呐钠纳难挠脑恼闹铙讷馁内拟腻铌鲵撵辇鲶酿鸟茑袅聂啮镊镍陧蘖嗫颟蹑柠狞宁拧泞苎咛聍钮纽脓浓农侬哝驽钕诺傩疟欧鸥殴呕沤讴怄瓯盘蹒庞抛疱赔辔喷鹏纰罴铍骗谝骈飘缥频贫嫔苹凭评泼颇钋扑铺朴谱镤镨栖脐齐骑岂启气弃讫蕲骐绮桤碛颀颃鳍牵钎铅迁签谦钱钳潜浅谴堑佥荨悭骞缱椠钤枪呛墙蔷强抢嫱樯戗炝锖锵镪羟跄锹桥乔侨翘窍诮谯荞缲硗跷窃惬锲箧钦亲寝锓轻氢倾顷请庆揿鲭琼穷茕蛱巯赇虮鳅趋区躯驱龋诎岖阒觑鸲颧权劝诠绻辁铨却鹊确阕阙悫让饶扰绕荛娆桡热韧认纫饪轫荣绒嵘蝾缛铷颦软锐蚬闰润洒萨飒鳃赛伞毵糁丧骚扫缫涩啬铯穑杀刹纱铩鲨筛晒酾删闪陕赡缮讪姗骟钐鳝墒伤赏垧殇觞烧绍赊摄慑设厍滠畲绅审婶肾渗诜谂渖声绳胜师狮湿诗时蚀实识驶势适释饰视试谥埘莳弑轼贳铈鲥寿兽绶枢输书赎属术树竖数摅纾帅闩双谁税顺说硕烁铄丝饲厮驷缌锶鸶耸怂颂讼诵擞薮馊飕锼苏诉肃谡稣虽随绥岁谇孙损笋荪狲缩琐锁唢睃獭挞闼铊鳎台态钛鲐摊贪瘫滩坛谭谈叹昙钽锬顸汤烫傥饧铴镗涛绦讨韬铽腾誊锑题体屉缇鹈阗条粜龆鲦贴铁厅听烃铜统恸头钭秃图钍团抟颓蜕饨脱鸵驮驼椭箨鼍袜娲腽弯湾顽万纨绾网辋韦违围为潍维苇伟伪纬谓卫诿帏闱沩涠玮韪炜鲔温闻纹稳问阌瓮挝蜗涡窝卧莴龌呜钨乌诬无芜吴坞雾务误邬庑怃妩骛鹉鹜锡牺袭习铣戏细饩阋玺觋虾辖峡侠狭厦吓硖鲜纤贤衔闲显险现献县馅羡宪线苋莶藓岘猃娴鹇痫蚝籼跹厢镶乡详响项芗饷骧缃飨萧嚣销晓啸哓潇骁绡枭箫协挟携胁谐写泻谢亵撷绁缬锌衅兴陉荥凶汹锈绣馐鸺虚嘘须许叙绪续诩顼轩悬选癣绚谖铉镟学谑泶鳕勋询寻驯训讯逊埙浔鲟压鸦鸭哑亚讶垭娅桠氩阉烟盐严岩颜阎艳厌砚彦谚验厣赝俨兖谳恹闫酽魇餍鼹鸯杨扬疡阳痒养样炀瑶摇尧遥窑谣药轺鹞鳐爷页业叶靥谒邺晔烨医铱颐遗仪蚁艺亿忆义诣议谊译异绎诒呓峄饴怿驿缢轶贻钇镒镱瘗舣荫阴银饮隐铟瘾樱婴鹰应缨莹萤营荧蝇赢颖茔莺萦蓥撄嘤滢潆璎鹦瘿颏罂哟拥佣痈踊咏镛优忧邮铀犹诱莸铕鱿舆鱼渔娱与屿语狱誉预驭伛俣谀谕蓣嵛饫阈妪纡觎欤钰鹆鹬龉鸳渊辕园员圆缘远橼鸢鼋约跃钥粤悦阅钺郧匀陨运蕴酝晕韵郓芸恽愠纭韫殒氲杂灾载攒暂赞瓒趱錾赃脏驵凿枣责择则泽赜啧帻箦贼谮赠综缯轧铡闸栅诈斋债毡盏斩辗崭栈战绽谵张涨帐账胀赵诏钊蛰辙锗这谪辄鹧贞针侦诊镇阵浈缜桢轸赈祯鸩挣睁狰争帧症郑证诤峥钲铮筝织职执纸挚掷帜质滞骘栉栀轵轾贽鸷蛳絷踬踯觯钟终种肿众锺诌轴皱昼骤纣绉猪诸诛烛瞩嘱贮铸驻伫槠铢专砖转赚啭馔颞桩庄装妆壮状锥赘坠缀骓缒谆准着浊诼镯兹资渍谘缁辎赀眦锱龇鲻踪总纵偬邹诹驺鲰诅组镞钻缵躜鳟翱并卜沉丑淀迭斗范干皋硅柜后伙秸杰诀夸里凌么霉捻凄扦圣尸抬涂洼喂污锨咸蝎彝涌游吁御愿岳云灶扎札筑于志注凋讠谫郄勐凼坂垅垴埯埝苘荬荮莜莼菰藁揸吒吣咔咝咴噘噼嚯幞岙嵴彷徼犸狍馀馇馓馕愣憷懔丬溆滟溷漤潴澹甯纟绔绱珉枧桊桉槔橥轱轷赍肷胨飚煳煅熘愍淼砜磙眍钚钷铘铞锃锍锎锏锘锝锪锫锿镅镎镢镥镩镲稆鹋鹛鹱疬疴痖癯裥襁耢颥螨麴鲅鲆鲇鲞鲴鲺鲼鳊鳋鳘鳙鞒鞴齄&quot;;
    const string traditional = &quot;錒皚藹礙愛噯嬡璦曖靄諳銨鵪骯襖奧媼驁鰲壩罷鈀擺敗唄頒辦絆鈑幫綁鎊謗剝飽寶報鮑鴇齙輩貝鋇狽備憊鵯賁錛繃筆畢斃幣閉蓽嗶潷鉍篳蹕邊編貶變辯辮芐緶籩標驃颮飆鏢鑣鰾鱉別癟瀕濱賓擯儐繽檳殯臏鑌髕鬢餅稟撥缽鉑駁餑鈸鵓補鈽財參蠶殘慚慘燦驂黲蒼艙倉滄廁側冊測惻層詫鍤儕釵攙摻蟬饞讒纏鏟產闡顫囅諂讖蕆懺嬋驏覘禪鐔場嘗長償腸廠暢倀萇悵閶鯧鈔車徹硨塵陳襯傖諶櫬磣齔撐稱懲誠騁棖檉鋮鐺癡遲馳恥齒熾飭鴟沖衝蟲寵銃疇躊籌綢儔幬讎櫥廚鋤雛礎儲觸處芻絀躕傳釧瘡闖創愴錘綞純鶉綽輟齪辭詞賜鶿聰蔥囪從叢蓯驄樅湊輳躥竄攛錯銼鹺達噠韃帶貸駘紿擔單鄲撣膽憚誕彈殫賧癉簞當擋黨蕩檔讜碭襠搗島禱導盜燾燈鄧鐙敵滌遞締糴詆諦綈覿鏑顛點墊電巔鈿癲釣調銚鯛諜疊鰈釘頂錠訂鋌丟銩東動棟凍崠鶇竇犢獨讀賭鍍瀆櫝牘篤黷鍛斷緞籪兌隊對懟鐓噸頓鈍燉躉奪墮鐸鵝額訛惡餓諤堊閼軛鋨鍔鶚顎顓鱷誒兒爾餌貳邇鉺鴯鮞發罰閥琺礬釩煩販飯訪紡鈁魴飛誹廢費緋鐨鯡紛墳奮憤糞僨豐楓鋒風瘋馮縫諷鳳灃膚輻撫輔賦復負訃婦縛鳧駙紱紼賻麩鮒鰒釓該鈣蓋賅桿趕稈贛尷搟紺岡剛鋼綱崗戇鎬睪誥縞鋯擱鴿閣鉻個紇鎘潁給亙賡綆鯁龔宮鞏貢鉤溝茍構購夠詬緱覯蠱顧詁轂鈷錮鴣鵠鶻剮掛鴰摑關觀館慣貫詿摜鸛鰥廣獷規歸龜閨軌詭貴劊匭劌媯檜鮭鱖輥滾袞緄鯀鍋國過堝咼幗槨蟈鉿駭韓漢闞絎頡號灝顥閡鶴賀訶闔蠣橫轟鴻紅黌訌葒閎鱟壺護滬戶滸鶘嘩華畫劃話驊樺鏵懷壞歡環還緩換喚瘓煥渙奐繯鍰鯇黃謊鰉揮輝毀賄穢會燴匯諱誨繪詼薈噦澮繢琿暉葷渾諢餛閽獲貨禍鈥鑊擊機積饑跡譏雞績緝極輯級擠幾薊劑濟計記際繼紀訐詰薺嘰嚌驥璣覬齏磯羈蠆躋霽鱭鯽夾莢頰賈鉀價駕郟浹鋏鎵蟯殲監堅箋間艱緘繭檢堿鹼揀撿簡儉減薦檻鑒踐賤見鍵艦劍餞漸濺澗諫縑戔戩瞼鶼筧鰹韉將漿蔣槳獎講醬絳韁膠澆驕嬌攪鉸矯僥腳餃繳絞轎較撟嶠鷦鮫階節潔結誡屆癤頜鮚緊錦僅謹進晉燼盡勁荊莖巹藎饉縉贐覲鯨驚經頸靜鏡徑痙競凈剄涇逕弳脛靚糾廄舊鬮鳩鷲駒舉據鋸懼劇詎屨櫸颶鉅鋦窶齟鵑絹錈鐫雋覺決絕譎玨鈞軍駿皸開凱剴塏愾愷鎧鍇龕閌鈧銬顆殼課騍緙軻鈳錁頷墾懇齦鏗摳庫褲嚳塊儈鄶噲膾寬獪髖礦曠況誆誑鄺壙纊貺虧巋窺饋潰匱蕢憒聵簣閫錕鯤擴闊蠐蠟臘萊來賴崍徠淶瀨賚睞錸癩籟藍欄攔籃闌蘭瀾讕攬覽懶纜爛濫嵐欖斕鑭襤瑯閬鋃撈勞澇嘮嶗銠鐒癆樂鰳鐳壘類淚誄縲籬貍離鯉禮麗厲勵礫歷瀝隸儷酈壢藶蒞蘺嚦邐驪縭櫪櫟轢礪鋰鸝癘糲躒靂鱺鱧倆聯蓮連鐮憐漣簾斂臉鏈戀煉練蘞奩瀲璉殮褳襝鰱糧涼兩輛諒魎療遼鐐繚釕鷯獵臨鄰鱗凜賃藺廩檁轔躪齡鈴靈嶺領綾欞蟶鯪餾劉瀏騮綹鎦鷚龍聾嚨籠壟攏隴蘢瀧瓏櫳朧礱樓婁摟簍僂蔞嘍嶁鏤瘺耬螻髏蘆盧顱廬爐擄鹵虜魯賂祿錄陸壚擼嚕閭瀘淥櫨櫓轤輅轆氌臚鸕鷺艫鱸巒攣孿灤亂臠孌欒鸞鑾掄輪倫侖淪綸論圇蘿羅邏鑼籮騾駱絡犖玀濼欏腡鏍驢呂鋁侶屢縷慮濾綠櫚褸鋝嘸媽瑪碼螞馬罵嗎嘜嬤榪買麥賣邁脈勱瞞饅蠻滿謾縵鏝顙鰻貓錨鉚貿麼沒鎂門悶們捫燜懣鍆錳夢瞇謎彌覓冪羋謐獼禰綿緬澠靦黽廟緲繆滅憫閩閔緡鳴銘謬謨驀饃歿鏌謀畝鉬吶鈉納難撓腦惱鬧鐃訥餒內擬膩鈮鯢攆輦鯰釀鳥蔦裊聶嚙鑷鎳隉蘗囁顢躡檸獰寧擰濘苧嚀聹鈕紐膿濃農儂噥駑釹諾儺瘧歐鷗毆嘔漚謳慪甌盤蹣龐拋皰賠轡噴鵬紕羆鈹騙諞駢飄縹頻貧嬪蘋憑評潑頗釙撲鋪樸譜鏷鐠棲臍齊騎豈啟氣棄訖蘄騏綺榿磧頎頏鰭牽釬鉛遷簽謙錢鉗潛淺譴塹僉蕁慳騫繾槧鈐槍嗆墻薔強搶嬙檣戧熗錆鏘鏹羥蹌鍬橋喬僑翹竅誚譙蕎繰磽蹺竊愜鍥篋欽親寢鋟輕氫傾頃請慶撳鯖瓊窮煢蛺巰賕蟣鰍趨區軀驅齲詘嶇闃覷鴝顴權勸詮綣輇銓卻鵲確闋闕愨讓饒擾繞蕘嬈橈熱韌認紉飪軔榮絨嶸蠑縟銣顰軟銳蜆閏潤灑薩颯鰓賽傘毿糝喪騷掃繅澀嗇銫穡殺剎紗鎩鯊篩曬釃刪閃陜贍繕訕姍騸釤鱔墑傷賞坰殤觴燒紹賒攝懾設厙灄畬紳審嬸腎滲詵諗瀋聲繩勝師獅濕詩時蝕實識駛勢適釋飾視試謚塒蒔弒軾貰鈰鰣壽獸綬樞輸書贖屬術樹豎數攄紓帥閂雙誰稅順說碩爍鑠絲飼廝駟緦鍶鷥聳慫頌訟誦擻藪餿颼鎪蘇訴肅謖穌雖隨綏歲誶孫損筍蓀猻縮瑣鎖嗩脧獺撻闥鉈鰨臺態鈦鮐攤貪癱灘壇譚談嘆曇鉭錟頇湯燙儻餳鐋鏜濤絳討韜鋱騰謄銻題體屜緹鵜闐條糶齠鰷貼鐵廳聽烴銅統慟頭鈄禿圖釷團摶頹蛻飩脫鴕馱駝橢籜鼉襪媧膃彎灣頑萬紈綰網輞韋違圍為濰維葦偉偽緯謂衛諉幃闈溈潿瑋韙煒鮪溫聞紋穩問閿甕撾蝸渦窩臥萵齷嗚鎢烏誣無蕪吳塢霧務誤鄔廡憮嫵騖鵡鶩錫犧襲習銑戲細餼鬩璽覡蝦轄峽俠狹廈嚇硤鮮纖賢銜閑顯險現獻縣餡羨憲線莧薟蘚峴獫嫻鷴癇蠔秈躚廂鑲鄉詳響項薌餉驤緗饗蕭囂銷曉嘯嘵瀟驍綃梟簫協挾攜脅諧寫瀉謝褻擷紲纈鋅釁興陘滎兇洶銹繡饈鵂虛噓須許敘緒續詡頊軒懸選癬絢諼鉉鏇學謔澩鱈勛詢尋馴訓訊遜塤潯鱘壓鴉鴨啞亞訝埡婭椏氬閹煙鹽嚴巖顏閻艷厭硯彥諺驗厴贗儼兗讞懨閆釅魘饜鼴鴦楊揚瘍陽癢養樣煬瑤搖堯遙窯謠藥軺鷂鰩爺頁業葉靨謁鄴曄燁醫銥頤遺儀蟻藝億憶義詣議誼譯異繹詒囈嶧飴懌驛縊軼貽釔鎰鐿瘞艤蔭陰銀飲隱銦癮櫻嬰鷹應纓瑩螢營熒蠅贏穎塋鶯縈鎣攖嚶瀅瀠瓔鸚癭頦罌喲擁傭癰踴詠鏞優憂郵鈾猶誘蕕銪魷輿魚漁娛與嶼語獄譽預馭傴俁諛諭蕷崳飫閾嫗紆覦歟鈺鵒鷸齬鴛淵轅園員圓緣遠櫞鳶黿約躍鑰粵悅閱鉞鄖勻隕運蘊醞暈韻鄆蕓惲慍紜韞殞氳雜災載攢暫贊瓚趲鏨贓臟駔鑿棗責擇則澤賾嘖幘簀賊譖贈綜繒軋鍘閘柵詐齋債氈盞斬輾嶄棧戰綻譫張漲帳賬脹趙詔釗蟄轍鍺這謫輒鷓貞針偵診鎮陣湞縝楨軫賑禎鴆掙睜猙爭幀癥鄭證諍崢鉦錚箏織職執紙摯擲幟質滯騭櫛梔軹輊贄鷙螄縶躓躑觶鐘終種腫眾鍾謅軸皺晝驟紂縐豬諸誅燭矚囑貯鑄駐佇櫧銖專磚轉賺囀饌顳樁莊裝妝壯狀錐贅墜綴騅縋諄準著濁諑鐲茲資漬諮緇輜貲眥錙齜鯔蹤總縱傯鄒諏騶鯫詛組鏃鉆纘躦鱒翺並蔔沈醜澱叠鬥範幹臯矽櫃後夥稭傑訣誇裏淩麽黴撚淒扡聖屍擡塗窪餵汙鍁鹹蠍彜湧遊籲禦願嶽雲竈紮劄築於誌註雕訁譾郤猛氹阪壟堖垵墊檾蕒葤蓧蒓菇槁摣咤唚哢噝噅撅劈謔襆嶴脊仿僥獁麅餘餷饊饢楞怵懍爿漵灩混濫瀦淡寧糸絝緔瑉梘棬案橰櫫軲軤賫膁腖飈糊煆溜湣渺碸滾瞘鈈鉕鋣銱鋥鋶鐦鐧鍩鍀鍃錇鎄鎇鎿鐝鑥鑹鑔穭鶓鶥鸌癧屙瘂臒襇繈耮顬蟎麯鮁鮃鮎鯗鯝鯴鱝鯿鰠鰵鱅鞽韝齇&quot;;

    static char[] TradToSimp = new char[char.MaxValue];

    static char GetSimp(char c) {
      char s = TradToSimp[c];
      return s == '\0' ? c : s;
    }

    public Trie() {
      int len = Math.Min(simplify.Length, traditional.Length);
      for (int i = 0; i &lt; len; i++) {
        TradToSimp[traditional[i]] = simplify[i];
      }
    }

    private TrieNode root_ = new TrieNode();

    public void Init(IEnumerable&lt;string&gt; strs) {
      if(strs != null) {
        foreach (var str in strs) {
          AddModelString(str.Trim());
        }
      }
    }

    public void AddModelString(string str) {
      if(str != null &amp;&amp; str.Length &gt; 0) {
        var thisNode = root_;
        for (int index = 0; index &lt; str.Length;  ++index) {
          char c = GetSimp(str[index]);
          thisNode = thisNode.GetNextNode(c);
        }
        thisNode.vis = true;
      }
    }

    public bool HasKeyWorld(string str, int starIndex, int endIndex) {
      for(int head = starIndex; head &lt; endIndex; ++head) {
        var thisNode = root_;
        for (int index = head; index &lt; endIndex; ++index) {
          if (!thisNode.TryGetValue(GetSimp(str[index]), out var node)) {
            break;
          }
          thisNode = node;
          if (thisNode.vis) return true;
        }
      }

      return false;
    }
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法和数据结构(目录)]]></title>
        <id>https://jerilee.github.io/post/suan-fa-he-shu-ju-jie-gou-mu-lu/</id>
        <link href="https://jerilee.github.io/post/suan-fa-he-shu-ju-jie-gou-mu-lu/">
        </link>
        <updated>2020-07-18T01:29:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据结构">数据结构</h1>
<h2 id="-11-线段树-segment-tree">---- 1.1  <a href="https://jerilee.github.io/post/ji-chu-shu-ju-jie-gou/">线段树 Segment Tree</a></h2>
<h2 id="-12-堆-heap">---- 1.2  <a href="https://jerilee.github.io/post/ji-chu-shu-ju-jie-gou-dui/">堆 Heap</a></h2>
<h2 id="-13-字典树-trie">---- 1.3  <a href="https://jerilee.github.io/post/zi-dian-shu-trie/">字典树 Trie</a></h2>
<h2 id="-14-树状数组-tree-array">---- 1.4  <a href="not_write">树状数组 Tree Array</a></h2>
<h2 id="-15-有序树">---- 1.5 有序树</h2>
<h2 id="-151-avl树">------------ 1.5.1 AVL树</h2>
<h2 id="-152-红黑树">------------ 1.5.2 红黑树</h2>
<h2 id="-152-b树-b树-b-树-b树">------------ 1.5.2 B树 B+树 B-树 B*树</h2>
<h1 id="算法">算法</h1>
<h2 id="-21-字符串处理">---- 2.1  字符串处理</h2>
<h2 id="-211-kmp字符串匹配">------------ 2.1.1  <a href="https://jerilee.github.io/post/ji-chu-suan-fa-kmp/">KMP字符串匹配</a></h2>
<h2 id="-212-manacher回文串">------------ 2.1.2  Manacher回文串</h2>
<h2 id="-213-ac自动机">------------ 2.1.3  <a href="xxx">AC自动机</a></h2>
<h2 id="-22-huffman树">---- 2.2  Huffman树</h2>
<h2 id="-23-lis">---- 2.3  Lis</h2>
<h2 id="-24-排序算法简单写一下">---- 2.4  排序算法（简单写一下）</h2>
<h1 id="c代码模板">C#代码模板</h1>
<h2 id="-31-敏感词匹配trie">---- 3.1 <a href="http://localhost:4000/post/dai-ma-mo-ban-min-gan-ci-pi-pei/">敏感词匹配Trie</a></h2>
<h1 id="c代码模板-2">C++代码模板</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#笔记]]></title>
        <id>https://jerilee.github.io/post/cbi-ji/</id>
        <link href="https://jerilee.github.io/post/cbi-ji/">
        </link>
        <updated>2020-07-13T13:28:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="c笔记">C#笔记</h2>
<h3 id="c部分类">C#部分类</h3>
<p>部分类可以定义部分方法。部分方法在部分类中定义，但没有方法体，在另一个部分类中执行。</p>
<pre><code class="language-C#">public partial class MyClass {
  partial void MyMethod();
}

public partial class MyClass {
  partial void MyMethod(){
    
  }
}
</code></pre>
<p>部分方法不能有返回值。<br>
部分方法如果没有实现，编译器不会编译这个方法。</p>
<h3 id="字符串查找">字符串查找</h3>
<pre><code class="language-C#">string.Contains();
string.IndexOf();
</code></pre>
<h3 id="dictionary和-sorteddictionary">Dictionary和 SortedDictionary</h3>
<pre><code class="language-C#">SortedDictionary&lt;string, string&gt; dic = new SortedDictionary&lt;string, string&gt;();
dic.Add(&quot;1&quot;, &quot;Tom&quot;);
dic.Add(&quot;1&quot;, &quot;Jeri&quot;); //不可以重复添加

Dictionary&lt;string, string&gt; dic = new Dictionary&lt;string, string&gt;();
dic.Add(&quot;1&quot;, &quot;Tom&quot;);
dic.Add(&quot;1&quot;, &quot;Jeri&quot;); //不可以重复添加
//SortedList也不可以重复Add
</code></pre>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2?view=netcore-3.1">Dictionary文档</a></p>
<h3 id="linq库">Linq库</h3>
<p>Select和Where都是延迟加载</p>
<pre><code class="language-C#">IEnumerable&lt;T&gt;.Select(Func func);
IEnumerable&lt;T&gt;.Where(Func func);
</code></pre>
<h3 id="元组">元组</h3>
<h4 id="引用元组-tuple">引用元组 Tuple</h4>
<p>元素最多8个，并且第8个元素是Tuple<br>
元素是只读<br>
元组为引用</p>
<pre><code class="language-C#">var testTuple1 = new Tuple&lt;int, int, int, int, int&gt;(1, 2, 3, 4, 5);
var testTuple2 = Tuple.Create&lt;int, int, int&gt;(1, 2, 3);
</code></pre>
<h4 id="值元组-valuetuple">值元组 ValueTuple</h4>
<p>元素属于字段，可读可写<br>
元素值传递</p>
<pre><code class="language-C#">//构造函数最多8个元素
var testTuple1 = new ValueTuple&lt;int, int, int, int, int&gt;(1, 2, 3, 4, 5);
var testTuple2 = ValueTuple.Create&lt;int, int, int&gt;(1, 2, 3);

//元素超过8个可以使用 Item8 Item9访问
var testTuple4 = new ValueTuple&lt;int, int, int, int, int, int, int, ValueTuple&lt;int, int&gt;&gt;(1, 2, 3, 4, 5, 6, 7, new ValueTuple&lt;int, int&gt;(8,9));
Console.WriteLine($&quot;Item 8: {testTuple4.Item8}, Item 8: {testTuple4.Item9}&quot;);
Console.WriteLine($&quot;Item 8: {testTuple4.Rest.Item1}, Item 8: {testTuple4.Rest.Item2}&quot;);

// 解构
var testTuple42 = Tuple.Create&lt;int, int, int&gt;(1, 2, 3);
var (_, x, _) = testTuple42;
</code></pre>
<h3 id="多线程">多线程</h3>
<pre><code class="language-C#">
static void DoFunction(Object obj) {
}
static void RunTest() {
  var t = new System.Threading.Thread(new System.Threading.ParameterizedThreadStart(DoFunction));
  t.Start(new object());
  while (t.IsAlive) {
    System.Threading.Thread.Sleep(50);
  }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基础算法（KMP）]]></title>
        <id>https://jerilee.github.io/post/ji-chu-suan-fa-kmp/</id>
        <link href="https://jerilee.github.io/post/ji-chu-suan-fa-kmp/">
        </link>
        <updated>2020-07-12T05:02:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础算法">基础算法</h1>
<p>@(算法)[算法|KMP|字符串]</p>
<hr>
<p>[TOC]</p>
<h2 id="kmp">KMP</h2>
<p>KMP特点：字符串匹配算法，从S串中匹配T串，KMP算法时间复杂度为O(N+M)</p>
<h3 id="逻辑">逻辑</h3>
<p>这里有两个字符串，一个A串，一个B串，从A串中匹配B串出现的位置<br>
A=&quot;abababcababa&quot;<br>
B=&quot;ababcababa&quot;</p>
<p><strong>Next数组</strong><br>
KMP里最重要的Next数组计算。<br>
next数组的含义：一个固定字符串的最长前缀和最长后缀相同的长度，然后再减1 （计算机下标从0开始）。<br>
很明显<br>
&quot;aba&quot;的前缀和后缀相同的最长串为&quot;a&quot;，所以长度为1<br>
&quot;abab&quot;的前缀和后缀相同的最长串为&quot;ab&quot;，所以长度为2<br>
可以推出next数组：<br>
<img src="https://jerilee.github.io/post-images/1594647097197.jpg" alt="" loading="lazy"><br>
第一行为字符串B<br>
第二行为固定字符串的<strong>前缀和后缀相同的最长串</strong><br>
<strong>Next数组</strong>为第二行数值减1</p>
<p>KMP匹配和Next数组的处理是一摸一样的逻辑。<br>
如下图，蓝色区域是相同的部分，对于&quot;ababcabab&quot;串来说， 它的最长的相同前缀和后缀就是&quot;abab&quot;，所以当字符'a'和'c'失配的时候，字符串最长可用部分为蓝色部分，所以从这个位置继续匹配。<br>
下面重复相同步骤。<br>
<img src="https://jerilee.github.io/post-images/1594648216459.png" alt="" loading="lazy"></p>
<h3 id="code">Code</h3>
<h4 id="c代码">C++代码</h4>
<pre><code class="language-C++">void Kmp::GetNext(std::string str, std::vector&lt;int&gt;&amp; next) {
  next[0] = -1;
  for (int i = 1, k = -1; i &lt; str.length(); ++i) {
    while (k &gt; -1 &amp;&amp; str[k + 1] != str[i])
      k = next[k];
    if (str[k + 1] == str[i])
      k = k + 1;
    next[i] = k;
  }
}

int Kmp::FindByKmp(std::string str1, std::string str2) {
  std::vector&lt;int&gt; next(str2.length());
  GetNext(str2, next);
  for (int i = 0, k = -1; i &lt; str1.length(); i++) {
    while (k &gt; -1 &amp;&amp; str2[k + 1] != str1[i]) {
      k = next[k];
    }

    if (str2[k + 1] == str1[i]) {
      ++k;
    }

    if (k == str2.length() - 1) {
      return i - (int)str2.length() + 1;
    }
  }
  return -1;
}

</code></pre>
<h4 id="c代码-2">C#代码</h4>
<pre><code class="language-C#">public static int[] GetNext(string str) {
  int[] next = new int[str.Length];
  next[0] = -1;
  for (int i = 1, k = -1; i &lt; str.Length; ++i) {
    while (k &gt; -1 &amp;&amp; str[k + 1] != str[i]){
      k = next[k];
    }
    if (str[k + 1] == str[i]){
      k = k + 1;
    }
    next[i] = k;
  }
  return next;
}

public static int FindByKmp(this string str1, string str2) {
    var next = GetNext(str2);
    for (int i = 0, k = -1; i &lt; str1.Length; i++) {
    while (k &gt; -1 &amp;&amp; str2[k + 1] != str1[i]) {
        k = next[k];
    }

    if (str2[k + 1] == str1[i]) {
        ++k;
    }
        
    if (k == str2.Length - 1){
        return i - str2.Length + 1;
    }
    }
    return -1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基础数据结构（堆Segment Tree）]]></title>
        <id>https://jerilee.github.io/post/ji-chu-shu-ju-jie-gou-dui/</id>
        <link href="https://jerilee.github.io/post/ji-chu-shu-ju-jie-gou-dui/">
        </link>
        <updated>2020-07-12T01:37:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础数据结构">基础数据结构</h1>
<p>@(数据结构)[堆|Segment Tree|数据结构]</p>
<hr>
<p>[TOC]</p>
<h2 id="堆">堆</h2>
<h3 id="原理">原理</h3>
<p>堆属于二叉树，属于完全二叉树。<br>
堆特性 ： 以大顶堆为例，父节点比两个子节点的值都要大。如图，5号节点，它的v值比10号节点和11号节点都要大。<br>
<img src="https://jerilee.github.io/post-images/1594513997324.png" alt="" loading="lazy"></p>
<h3 id="实现方法">实现方法</h3>
<p>堆通常使用数组实现。<br>
每个堆节点（index）的左子节点为（index*2 + 1），右子节点为（index*2 + 2）</p>
<h4 id="插入元素">插入元素</h4>
<p>1.因为堆属于完全二叉树，所以新元素放在数组的最末尾。<br>
2.如果<strong>当前节点</strong>比<strong>父节点</strong>更优先，则和父节点交换，递归向上比较。</p>
<h4 id="删除最优先元素">删除最优先元素</h4>
<p>因为堆属于完全二叉树，删除最优先元素时：<br>
1.先将0号元素与末尾元素交换，再删除最末尾元素。<br>
2.该节点是否比子节点要小，如果确实是这样，则从两个子节点中找一个更大的和自己交换，再递归向下比较。</p>
<h4 id="查找最优先元素">查找最优先元素</h4>
<p>如果堆不为空，则最优先元素一定是根节点。</p>
<h3 id="code">Code</h3>
<h4 id="c代码">C#代码</h4>
<pre><code class="language-C#">
  public class Heap&lt;T&gt; where T: IComparable&lt;T&gt; {
    private List&lt;T&gt; list = new List&lt;T&gt;();
    private int count = 0;

    public Heap() {
    }

    public void Add(T value) {
      if(list.Count &gt; count) {
        list[count] = value;
      } else {
        list.Add(value);
      }

      CheckAdd(count);
      ++count;
    }

    private void CheckAdd(int index) {
      if(index &gt; 0) {
        int father = (index - 1 ) &gt;&gt; 1;
        if (list[index].CompareTo(list[father]) &lt; 0) {
          T temp = list[index];
          list[index] = list[father];
          list[father] = temp;
          CheckAdd(father);
        }
      }
    }

    public T Top() {
      if(count &gt; 0) {
        return list[0];
      }
      return default;
    }

    public int Count =&gt; count;
    public bool IsEmpty =&gt; count == 0;

    public bool Pop() {
      if(count &gt; 0) {
        --count;
        if (count &gt; 0) {
          T temp = list[0];
          list[0] = list[count];
          list[count] = temp;
          CheckPop(0);
        }
        return true;
      }
      return false;
    }

    private void CheckPop(int index) {
      int leftSon = index &lt;&lt; 1 | 1;
      int rightSon = leftSon + 1;
      if (leftSon &lt; Count) {
        int upSon = rightSon &lt; Count &amp;&amp; list[rightSon].CompareTo(list[leftSon]) &lt; 0 ? rightSon : leftSon;
        if (list[upSon].CompareTo(list[index]) &lt; 0) {
          T temp = list[index];
          list[index] = list[upSon];
          list[upSon] = temp;
          CheckPop(upSon);
        }
      }
    }
  }

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基础数据结构（线段树Segment Tree）]]></title>
        <id>https://jerilee.github.io/post/ji-chu-shu-ju-jie-gou/</id>
        <link href="https://jerilee.github.io/post/ji-chu-shu-ju-jie-gou/">
        </link>
        <updated>2020-07-11T15:05:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础数据结构">基础数据结构</h1>
<p>@(数据结构)[线段树|Segment Tree|数据结构]</p>
<hr>
<p>[TOC]</p>
<h2 id="线段树segment-tree">线段树（Segment Tree）</h2>
<h3 id="特性">特性</h3>
<p>线段树属于二叉树，除叶节点外，其他节点的度都是2。<br>
线段树特性 ： 父节点的值为子节点值的和，便于求区间和。如图，5号节点，它的v值为10号节点和11号节点的和。<br>
<img src="https://jerilee.github.io/post-images/1594517169989.png" alt="" loading="lazy"></p>
<p>备注：线段树有多种形式，父节点也可以为两个子节点的最大值/最小值等。</p>
<h3 id="实现逻辑">实现逻辑</h3>
<p>如图，以<strong>下文C#引用实现</strong>为例，每个节点的value代表一个区间[left, right)的和，若一个元素代表[left, right)的和，那它的两个儿子分别代表[left, mid), [mid, right) 的和。<br>
<img src="https://jerilee.github.io/post-images/1594514907199.png" alt="" loading="lazy"></p>
<h4 id="创建线段树-参考函数buildtree">创建线段树 （参考函数BuildTree）</h4>
<p>创建树每个结点时，如果这个节点不是叶节点，先创建两个子节点，通过递归的方式创建完左右两棵子树时，再初始化该节点，这样就完成了以这个节点为根节点的线段树初始化。</p>
<h4 id="通过索引修改线段树的值-参考函数setvalue">通过索引修改线段树的值 （参考函数SetValue）</h4>
<p>通过递归的方式，找到索引所在的叶节点，修改叶节点的值，再从下往上修改路径上节点的值。</p>
<h4 id="查找区间和-参考函数-queryvalue">查找区间和 （参考函数 QueryValue）</h4>
<p>通过递归的方式，判断所要查找的区间覆盖在哪些节点。例如图例，若要查找[1, 6]区间的和，只需要2号节点[1,4]， 6号节点[5,6]求和。</p>
<h3 id="code">Code</h3>
<h4 id="c代码"><strong>C++代码</strong></h4>
<h4 id="c代码-数组实现这是一棵满二叉树"><strong>C#代码</strong> 数组实现，这是一棵满二叉树</h4>
<pre><code class="language-C#">  public class SegmentTree&lt;T&gt; where T : new() {
    T[] list;
    int Count;
    Func&lt;T, T, T&gt; addFunc;
    /// &lt;summary&gt;
    /// 构造函数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;collection&quot;&gt; 数据集合&lt;/param&gt;
    /// &lt;param name=&quot;func&quot;&gt; 两个T相加方法&lt;/param&gt;
    public SegmentTree(List&lt;T&gt; collection, Func&lt;T,T,T&gt; func) {
      if(collection.Count &gt; 0) {
        int temp = 1;
        while(temp &lt; collection.Count) {
          temp &lt;&lt;= 1;
        }
        Count = temp;
        list = new T[temp &lt;&lt; 1];
        addFunc = func;
        BuildTree(1, 0, temp, collection);
      } else {
        throw new Exception(&quot;List Count is Zero&quot;);
      }
    }

    private void BuildTree(int nodeId, int left, int right, List&lt;T&gt; collection) {
      if(left + 1 == right) {
        if(left &lt; collection.Count) {
          list[nodeId] = collection[left];
        } else {
          list[nodeId] = new T();
        }
        return;
      }

      int mid = (left + right) &gt;&gt; 1;
      BuildTree(nodeId &lt;&lt; 1, left, mid, collection);
      BuildTree(nodeId &lt;&lt; 1 | 1, mid, right, collection);
      list[nodeId] = addFunc(list[nodeId &lt;&lt; 1], list[nodeId &lt;&lt; 1 | 1]);
    }
    /// &lt;summary&gt;
    /// 设置值
    /// &lt;/summary&gt;
    public bool TrySetValue(int index, T value) {
      if (index &gt;= 0 &amp;&amp; index &lt; Count) {
        SetValue(1, 0, Count, index, value);
        return true;
      }
      return false;
    }

    private void SetValue(int nodeId, int left, int right, int index, T value) {
      if(left + 1 == right) {
        list[nodeId] = value;
        return;
      }
      int mid = (left + right) &gt;&gt; 1;
      if(index &lt; mid) {
        SetValue(nodeId &lt;&lt; 1, left, mid, index, value);
      } else {
        SetValue(nodeId &lt;&lt; 1 | 1, mid, right, index, value);
      }
      list[nodeId] = addFunc(list[nodeId &lt;&lt; 1], list[nodeId &lt;&lt; 1 | 1]);
    }
    /// &lt;summary&gt;
    /// 查询区间和
    /// &lt;/summary&gt;
    public T QueryValue(int left, int right) {
      if(left &lt; right &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= Count) {
        return QueryValue(1, 0, Count, left, right);
      }
      return default(T);
    }

    private T QueryValue(int nodeId, int left, int right, int qleft, int qright) {
      if(left == qleft &amp;&amp; right == qright) {
        return list[nodeId];
      }

      int mid = (left + right) &gt;&gt; 1;
      if(qright &lt;= mid) {
        return QueryValue(nodeId &lt;&lt; 1, left, mid, qleft, qright);
      }else if(qleft &gt;= mid) {
        return QueryValue(nodeId &lt;&lt; 1 | 1, mid, right, qleft, qright);
      } else {
        return addFunc(QueryValue(nodeId &lt;&lt; 1, left, mid, qleft, mid),
          QueryValue(nodeId &lt;&lt; 1 | 1, mid, right, mid, qright));
      }
    }
  }
</code></pre>
<h4 id="c代码-引用实现这不是满二叉树"><strong>C#代码</strong> 引用实现，这不是满二叉树</h4>
<pre><code class="language-C#">  public class SegmentTree2&lt;T&gt; where T : new() {
    private class Node {
      public int Left, Right;
      public Node LeftSon, RightSon;
      public T Value;
    }
    private Node root;
    Func&lt;T, T, T&gt; addFunc;
    /// &lt;summary&gt;
    /// 构造函数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;collection&quot;&gt; 数据集合&lt;/param&gt;
    /// &lt;param name=&quot;func&quot;&gt; 两个T相加方法&lt;/param&gt;
    public SegmentTree2(List&lt;T&gt; collection, Func&lt;T, T, T&gt; func) {
      if (collection.Count &gt; 0) {
        addFunc = func;
        root = BuildTree(0, collection.Count, collection);
      } else {
        throw new Exception(&quot;List Count is Zero&quot;);
      }
    }

    private Node BuildTree(int left, int right, List&lt;T&gt; collection) {
      Node node = new Node {
        Left = left,
        Right = right
      };
      if (left + 1 == right) {
        node.LeftSon = node.RightSon = default;
        node.Value = collection[left];
      } else {
        int mid = (left + right) &gt;&gt; 1;
        node.LeftSon = BuildTree(left, mid, collection);
        node.RightSon = BuildTree(mid, right, collection);
        node.Value = addFunc(node.LeftSon.Value, node.RightSon.Value);
      }
      return node;
    }
    /// &lt;summary&gt;
    /// 设置值
    /// &lt;/summary&gt;
    public bool TrySetValue(int index, T value) {
      if (index &gt;= root.Left &amp;&amp; index &lt; root.Right) {
        SetValue(root, index, value);
        return true;
      }
      return false;
    }

    private void SetValue(Node node, int index, T value) {
      if (node.Left + 1 == node.Right) {
        node.Value = value;
      } else {
        SetValue(index &lt; node.LeftSon.Right ? node.LeftSon : node.RightSon, index, value);
        node.Value = addFunc(node.LeftSon.Value, node.RightSon.Value);
      }
    }
    /// &lt;summary&gt;
    /// 查询区间和
    /// &lt;/summary&gt;
    public T QueryValue(int left, int right) {
      if (left &lt; right &amp;&amp; left &gt;= root.Left &amp;&amp; right &lt;= root.Right) {
        return QueryValue(root, left, right);
      }
      return default(T);
    }

    private T QueryValue(Node node, int qleft, int qright) {
      if (node.Left == qleft &amp;&amp; node.Right == qright) {
        return node.Value;
      }

      if (qright &lt;= node.LeftSon.Right) {
        return QueryValue(node.LeftSon, qleft, qright);
      } else if (qleft &gt;= node.LeftSon.Right) {
        return QueryValue(node.RightSon, qleft, qright);
      } else {
        return addFunc(QueryValue(node.LeftSon, qleft, node.LeftSon.Right),
          QueryValue(node.RightSon, node.RightSon.Left, qright));
      }
    }
  }
</code></pre>
]]></content>
    </entry>
</feed>