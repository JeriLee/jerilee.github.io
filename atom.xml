<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jerilee.github.io</id>
    <title>Jeri的博客</title>
    <updated>2020-07-13T14:33:09.171Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jerilee.github.io"/>
    <link rel="self" href="https://jerilee.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jerilee.github.io/images/avatar.png</logo>
    <icon>https://jerilee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Jeri的博客</rights>
    <entry>
        <title type="html"><![CDATA[C#笔记]]></title>
        <id>https://jerilee.github.io/post/cbi-ji/</id>
        <link href="https://jerilee.github.io/post/cbi-ji/">
        </link>
        <updated>2020-07-13T13:28:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="c笔记">C#笔记</h2>
<h3 id="c部分类">C#部分类</h3>
<p>部分类可以定义部分方法。部分方法在部分类中定义，但没有方法体，在另一个部分类中执行。</p>
<pre><code class="language-C#">public partial class MyClass {
  partial void MyMethod();
}

public partial class MyClass {
  partial void MyMethod(){
    
  }
}
</code></pre>
<p>部分方法不能有返回值。<br>
部分方法如果没有实现，编译器不会编译这个方法。</p>
<h3 id="字符串查找">字符串查找</h3>
<pre><code class="language-C#">string.Contains();
string.IndexOf();
</code></pre>
<h3 id="dictionary和-sorteddictionary">Dictionary和 SortedDictionary</h3>
<pre><code class="language-C#">SortedDictionary&lt;string, string&gt; dic = new SortedDictionary&lt;string, string&gt;();
dic.Add(&quot;1&quot;, &quot;Tom&quot;);
dic.Add(&quot;1&quot;, &quot;Jeri&quot;); //不可以重复添加

Dictionary&lt;string, string&gt; dic = new Dictionary&lt;string, string&gt;();
dic.Add(&quot;1&quot;, &quot;Tom&quot;);
dic.Add(&quot;1&quot;, &quot;Jeri&quot;); //不可以重复添加
//SortedList也不可以重复Add
</code></pre>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2?view=netcore-3.1">Dictionary文档</a></p>
<h3 id="linq库">Linq库</h3>
<p>Select和Where都是延迟加载</p>
<pre><code class="language-C#">IEnumerable&lt;T&gt;.Select(Func func);
IEnumerable&lt;T&gt;.Where(Func func);
</code></pre>
<h3 id="元组">元组</h3>
<h4 id="引用元组-tuple">引用元组 Tuple</h4>
<p>元素最多8个，并且第8个元素是Tuple<br>
元素是只读<br>
元组为引用</p>
<pre><code class="language-C#">var testTuple1 = new Tuple&lt;int, int, int, int, int&gt;(1, 2, 3, 4, 5);
var testTuple2 = Tuple.Create&lt;int, int, int&gt;(1, 2, 3);
</code></pre>
<h4 id="值元组-valuetuple">值元组 ValueTuple</h4>
<p>元素属于字段，可读可写<br>
元素值传递</p>
<pre><code class="language-C#">//构造函数最多8个元素
var testTuple1 = new ValueTuple&lt;int, int, int, int, int&gt;(1, 2, 3, 4, 5);
var testTuple2 = ValueTuple.Create&lt;int, int, int&gt;(1, 2, 3);

//元素超过8个可以使用 Item8 Item9访问
var testTuple4 = new ValueTuple&lt;int, int, int, int, int, int, int, ValueTuple&lt;int, int&gt;&gt;(1, 2, 3, 4, 5, 6, 7, new ValueTuple&lt;int, int&gt;(8,9));
Console.WriteLine($&quot;Item 8: {testTuple4.Item8}, Item 8: {testTuple4.Item9}&quot;);
Console.WriteLine($&quot;Item 8: {testTuple4.Rest.Item1}, Item 8: {testTuple4.Rest.Item2}&quot;);

// 解构
var testTuple42 = Tuple.Create&lt;int, int, int&gt;(1, 2, 3);
var (_, x, _) = testTuple42;
</code></pre>
<h3 id="多线程">多线程</h3>
<pre><code class="language-C#">
static void DoFunction(Object obj) {
}
static void RunTest() {
  var t = new System.Threading.Thread(new System.Threading.ParameterizedThreadStart(DoFunction));
  t.Start(new object());
  while (t.IsAlive) {
    System.Threading.Thread.Sleep(50);
  }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基础算法（KMP）]]></title>
        <id>https://jerilee.github.io/post/ji-chu-suan-fa-kmp/</id>
        <link href="https://jerilee.github.io/post/ji-chu-suan-fa-kmp/">
        </link>
        <updated>2020-07-12T05:02:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础算法">基础算法</h1>
<p>@(算法)[算法|KMP|字符串]</p>
<hr>
<p>[TOC]</p>
<h2 id="kmp">KMP</h2>
<p>KMP特点：字符串匹配算法，从S串中匹配T串，KMP算法时间复杂度为O(N+M)</p>
<h3 id="逻辑">逻辑</h3>
<p>这里有两个字符串，一个A串，一个B串，从A串中匹配B串出现的位置<br>
A=&quot;abababcababa&quot;<br>
B=&quot;ababcababa&quot;</p>
<p><strong>Next数组</strong><br>
KMP里最重要的Next数组计算。<br>
next数组的含义：一个固定字符串的最长前缀和最长后缀相同的长度，然后再减1 （计算机下标从0开始）。<br>
很明显<br>
&quot;aba&quot;的前缀和后缀相同的最长串为&quot;a&quot;，所以长度为1<br>
&quot;abab&quot;的前缀和后缀相同的最长串为&quot;ab&quot;，所以长度为2<br>
可以推出next数组：<br>
<img src="https://jerilee.github.io/post-images/1594647097197.jpg" alt="" loading="lazy"><br>
第一行为字符串B<br>
第二行为固定字符串的<strong>前缀和后缀相同的最长串</strong><br>
<strong>Next数组</strong>为第二行数值减1</p>
<p>KMP匹配和Next数组的处理是一摸一样的逻辑。<br>
如下图，蓝色区域是相同的部分，对于&quot;ababcabab&quot;串来说， 它的最长的相同前缀和后缀就是&quot;abab&quot;，所以当字符'a'和'c'失配的时候，字符串最长可用部分为蓝色部分，所以从这个位置继续匹配。<br>
下面重复相同步骤。<br>
<img src="https://jerilee.github.io/post-images/1594648216459.png" alt="" loading="lazy"></p>
<h3 id="code">Code</h3>
<h4 id="c代码">C++代码</h4>
<pre><code class="language-C++">void Kmp::GetNext(std::string str, std::vector&lt;int&gt;&amp; next) {
  next[0] = -1;
  for (int i = 1, k = -1; i &lt; str.length(); ++i) {
    while (k &gt; -1 &amp;&amp; str[k + 1] != str[i])
      k = next[k];
    if (str[k + 1] == str[i])
      k = k + 1;
    next[i] = k;
  }
}

int Kmp::FindByKmp(std::string str1, std::string str2) {
  std::vector&lt;int&gt; next(str2.length());
  GetNext(str2, next);
  for (int i = 0, k = -1; i &lt; str1.length(); i++) {
    while (k &gt; -1 &amp;&amp; str2[k + 1] != str1[i]) {
      k = next[k];
    }

    if (str2[k + 1] == str1[i]) {
      ++k;
    }

    if (k == str2.length() - 1) {
      return i - (int)str2.length() + 1;
    }
  }
  return -1;
}

</code></pre>
<h4 id="c代码-2">C#代码</h4>
<pre><code class="language-C#">public static int[] GetNext(string str) {
  int[] next = new int[str.Length];
  next[0] = -1;
  for (int i = 1, k = -1; i &lt; str.Length; ++i) {
    while (k &gt; -1 &amp;&amp; str[k + 1] != str[i]){
      k = next[k];
    }
    if (str[k + 1] == str[i]){
      k = k + 1;
    }
    next[i] = k;
  }
  return next;
}

public static int FindByKmp(this string str1, string str2) {
    var next = GetNext(str2);
    for (int i = 0, k = -1; i &lt; str1.Length; i++) {
    while (k &gt; -1 &amp;&amp; str2[k + 1] != str1[i]) {
        k = next[k];
    }

    if (str2[k + 1] == str1[i]) {
        ++k;
    }
        
    if (k == str2.Length - 1){
        return i - str2.Length + 1;
    }
    }
    return -1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基础数据结构（堆Segment Tree）]]></title>
        <id>https://jerilee.github.io/post/ji-chu-shu-ju-jie-gou-dui/</id>
        <link href="https://jerilee.github.io/post/ji-chu-shu-ju-jie-gou-dui/">
        </link>
        <updated>2020-07-12T01:37:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础数据结构">基础数据结构</h1>
<p>@(数据结构)[堆|Segment Tree|数据结构]</p>
<hr>
<p>[TOC]</p>
<h2 id="堆">堆</h2>
<h3 id="原理">原理</h3>
<p>堆属于二叉树，属于完全二叉树。<br>
堆特性 ： 以大顶堆为例，父节点比两个子节点的值都要大。如图，5号节点，它的v值比10号节点和11号节点都要大。<br>
<img src="https://jerilee.github.io/post-images/1594513997324.png" alt="" loading="lazy"></p>
<h3 id="实现方法">实现方法</h3>
<p>堆通常使用数组实现。<br>
每个堆节点（index）的左子节点为（index*2 + 1），右子节点为（index*2 + 2）</p>
<h4 id="插入元素">插入元素</h4>
<p>1.因为堆属于完全二叉树，所以新元素放在数组的最末尾。<br>
2.如果<strong>当前节点</strong>比<strong>父节点</strong>更优先，则和父节点交换，递归向上比较。</p>
<h4 id="删除最优先元素">删除最优先元素</h4>
<p>因为堆属于完全二叉树，删除最优先元素时：<br>
1.先将0号元素与末尾元素交换，再删除最末尾元素。<br>
2.该节点是否比子节点要小，如果确实是这样，则从两个子节点中找一个更大的和自己交换，再递归向下比较。</p>
<h4 id="查找最优先元素">查找最优先元素</h4>
<p>如果堆不为空，则最优先元素一定是根节点。</p>
<h3 id="code">Code</h3>
<h4 id="c代码">C#代码</h4>
<pre><code class="language-C#">
  public class Heap&lt;T&gt; where T: IComparable&lt;T&gt; {
    private List&lt;T&gt; list = new List&lt;T&gt;();
    private int count = 0;

    public Heap() {
    }

    public void Add(T value) {
      if(list.Count &gt; count) {
        list[count] = value;
      } else {
        list.Add(value);
      }

      CheckAdd(count);
      ++count;
    }

    private void CheckAdd(int index) {
      if(index &gt; 0) {
        int father = (index - 1 ) &gt;&gt; 1;
        if (list[index].CompareTo(list[father]) &lt; 0) {
          T temp = list[index];
          list[index] = list[father];
          list[father] = temp;
          CheckAdd(father);
        }
      }
    }

    public T Top() {
      if(count &gt; 0) {
        return list[0];
      }
      return default;
    }

    public int Count =&gt; count;
    public bool IsEmpty =&gt; count == 0;

    public bool Pop() {
      if(count &gt; 0) {
        --count;
        if (count &gt; 0) {
          T temp = list[0];
          list[0] = list[count];
          list[count] = temp;
          CheckPop(0);
        }
        return true;
      }
      return false;
    }

    private void CheckPop(int index) {
      int leftSon = index &lt;&lt; 1 | 1;
      int rightSon = leftSon + 1;
      if (leftSon &lt; Count) {
        int upSon = rightSon &lt; Count &amp;&amp; list[rightSon].CompareTo(list[leftSon]) &lt; 0 ? rightSon : leftSon;
        if (list[upSon].CompareTo(list[index]) &lt; 0) {
          T temp = list[index];
          list[index] = list[upSon];
          list[upSon] = temp;
          CheckPop(upSon);
        }
      }
    }
  }

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基础算法]]></title>
        <id>https://jerilee.github.io/post/ji-chu-suan-fa/</id>
        <link href="https://jerilee.github.io/post/ji-chu-suan-fa/">
        </link>
        <updated>2020-07-11T15:14:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础算法">基础算法</h1>
<p>@(算法)[KMP|Manacher|Huffman]</p>
<hr>
<h2 id="kmp">KMP</h2>
<h3 id="原理">原理</h3>
<h2 id="manacher算法">Manacher算法</h2>
<h2 id="huffman树">huffman树</h2>
<h2 id="lis算法">LIS算法</h2>
<h2 id="动态规划">动态规划</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基础数据结构（线段树Segment Tree）]]></title>
        <id>https://jerilee.github.io/post/ji-chu-shu-ju-jie-gou/</id>
        <link href="https://jerilee.github.io/post/ji-chu-shu-ju-jie-gou/">
        </link>
        <updated>2020-07-11T15:05:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础数据结构">基础数据结构</h1>
<p>@(数据结构)[线段树|Segment Tree|数据结构]</p>
<hr>
<p>[TOC]</p>
<h2 id="线段树segment-tree">线段树（Segment Tree）</h2>
<h3 id="特性">特性</h3>
<p>线段树属于二叉树，除叶节点外，其他节点的度都是2。<br>
线段树特性 ： 父节点的值为子节点值的和，便于求区间和。如图，5号节点，它的v值为10号节点和11号节点的和。<br>
<img src="https://jerilee.github.io/post-images/1594517169989.png" alt="" loading="lazy"></p>
<p>备注：线段树有多种形式，父节点也可以为两个子节点的最大值/最小值等。</p>
<h3 id="实现逻辑">实现逻辑</h3>
<p>如图，以<strong>下文C#引用实现</strong>为例，每个节点的value代表一个区间[left, right)的和，若一个元素代表[left, right)的和，那它的两个儿子分别代表[left, mid), [mid, right) 的和。<br>
<img src="https://jerilee.github.io/post-images/1594514907199.png" alt="" loading="lazy"></p>
<h4 id="创建线段树-参考函数buildtree">创建线段树 （参考函数BuildTree）</h4>
<p>创建树每个结点时，如果这个节点不是叶节点，先创建两个子节点，通过递归的方式创建完左右两棵子树时，再初始化该节点，这样就完成了以这个节点为根节点的线段树初始化。</p>
<h4 id="通过索引修改线段树的值-参考函数setvalue">通过索引修改线段树的值 （参考函数SetValue）</h4>
<p>通过递归的方式，找到索引所在的叶节点，修改叶节点的值，再从下往上修改路径上节点的值。</p>
<h4 id="查找区间和-参考函数-queryvalue">查找区间和 （参考函数 QueryValue）</h4>
<p>通过递归的方式，判断所要查找的区间覆盖在哪些节点。例如图例，若要查找[1, 6]区间的和，只需要2号节点[1,4]， 6号节点[5,6]求和。</p>
<h3 id="code">Code</h3>
<h4 id="c代码"><strong>C++代码</strong></h4>
<h4 id="c代码-数组实现这是一棵满二叉树"><strong>C#代码</strong> 数组实现，这是一棵满二叉树</h4>
<pre><code class="language-C#">  public class SegmentTree&lt;T&gt; where T : new() {
    T[] list;
    int Count;
    Func&lt;T, T, T&gt; addFunc;
    /// &lt;summary&gt;
    /// 构造函数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;collection&quot;&gt; 数据集合&lt;/param&gt;
    /// &lt;param name=&quot;func&quot;&gt; 两个T相加方法&lt;/param&gt;
    public SegmentTree(List&lt;T&gt; collection, Func&lt;T,T,T&gt; func) {
      if(collection.Count &gt; 0) {
        int temp = 1;
        while(temp &lt; collection.Count) {
          temp &lt;&lt;= 1;
        }
        Count = temp;
        list = new T[temp &lt;&lt; 1];
        addFunc = func;
        BuildTree(1, 0, temp, collection);
      } else {
        throw new Exception(&quot;List Count is Zero&quot;);
      }
    }

    private void BuildTree(int nodeId, int left, int right, List&lt;T&gt; collection) {
      if(left + 1 == right) {
        if(left &lt; collection.Count) {
          list[nodeId] = collection[left];
        } else {
          list[nodeId] = new T();
        }
        return;
      }

      int mid = (left + right) &gt;&gt; 1;
      BuildTree(nodeId &lt;&lt; 1, left, mid, collection);
      BuildTree(nodeId &lt;&lt; 1 | 1, mid, right, collection);
      list[nodeId] = addFunc(list[nodeId &lt;&lt; 1], list[nodeId &lt;&lt; 1 | 1]);
    }
    /// &lt;summary&gt;
    /// 设置值
    /// &lt;/summary&gt;
    public bool TrySetValue(int index, T value) {
      if (index &gt;= 0 &amp;&amp; index &lt; Count) {
        SetValue(1, 0, Count, index, value);
        return true;
      }
      return false;
    }

    private void SetValue(int nodeId, int left, int right, int index, T value) {
      if(left + 1 == right) {
        list[nodeId] = value;
        return;
      }
      int mid = (left + right) &gt;&gt; 1;
      if(index &lt; mid) {
        SetValue(nodeId &lt;&lt; 1, left, mid, index, value);
      } else {
        SetValue(nodeId &lt;&lt; 1 | 1, mid, right, index, value);
      }
      list[nodeId] = addFunc(list[nodeId &lt;&lt; 1], list[nodeId &lt;&lt; 1 | 1]);
    }
    /// &lt;summary&gt;
    /// 查询区间和
    /// &lt;/summary&gt;
    public T QueryValue(int left, int right) {
      if(left &lt; right &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= Count) {
        return QueryValue(1, 0, Count, left, right);
      }
      return default(T);
    }

    private T QueryValue(int nodeId, int left, int right, int qleft, int qright) {
      if(left == qleft &amp;&amp; right == qright) {
        return list[nodeId];
      }

      int mid = (left + right) &gt;&gt; 1;
      if(qright &lt;= mid) {
        return QueryValue(nodeId &lt;&lt; 1, left, mid, qleft, qright);
      }else if(qleft &gt;= mid) {
        return QueryValue(nodeId &lt;&lt; 1 | 1, mid, right, qleft, qright);
      } else {
        return addFunc(QueryValue(nodeId &lt;&lt; 1, left, mid, qleft, mid),
          QueryValue(nodeId &lt;&lt; 1 | 1, mid, right, mid, qright));
      }
    }
  }
</code></pre>
<h4 id="c代码-引用实现这不是满二叉树"><strong>C#代码</strong> 引用实现，这不是满二叉树</h4>
<pre><code class="language-C#">  public class SegmentTree2&lt;T&gt; where T : new() {
    private class Node {
      public int Left, Right;
      public Node LeftSon, RightSon;
      public T Value;
    }
    private Node root;
    Func&lt;T, T, T&gt; addFunc;
    /// &lt;summary&gt;
    /// 构造函数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;collection&quot;&gt; 数据集合&lt;/param&gt;
    /// &lt;param name=&quot;func&quot;&gt; 两个T相加方法&lt;/param&gt;
    public SegmentTree2(List&lt;T&gt; collection, Func&lt;T, T, T&gt; func) {
      if (collection.Count &gt; 0) {
        addFunc = func;
        root = BuildTree(0, collection.Count, collection);
      } else {
        throw new Exception(&quot;List Count is Zero&quot;);
      }
    }

    private Node BuildTree(int left, int right, List&lt;T&gt; collection) {
      Node node = new Node {
        Left = left,
        Right = right
      };
      if (left + 1 == right) {
        node.LeftSon = node.RightSon = default;
        node.Value = collection[left];
      } else {
        int mid = (left + right) &gt;&gt; 1;
        node.LeftSon = BuildTree(left, mid, collection);
        node.RightSon = BuildTree(mid, right, collection);
        node.Value = addFunc(node.LeftSon.Value, node.RightSon.Value);
      }
      return node;
    }
    /// &lt;summary&gt;
    /// 设置值
    /// &lt;/summary&gt;
    public bool TrySetValue(int index, T value) {
      if (index &gt;= root.Left &amp;&amp; index &lt; root.Right) {
        SetValue(root, index, value);
        return true;
      }
      return false;
    }

    private void SetValue(Node node, int index, T value) {
      if (node.Left + 1 == node.Right) {
        node.Value = value;
      } else {
        SetValue(index &lt; node.LeftSon.Right ? node.LeftSon : node.RightSon, index, value);
        node.Value = addFunc(node.LeftSon.Value, node.RightSon.Value);
      }
    }
    /// &lt;summary&gt;
    /// 查询区间和
    /// &lt;/summary&gt;
    public T QueryValue(int left, int right) {
      if (left &lt; right &amp;&amp; left &gt;= root.Left &amp;&amp; right &lt;= root.Right) {
        return QueryValue(root, left, right);
      }
      return default(T);
    }

    private T QueryValue(Node node, int qleft, int qright) {
      if (node.Left == qleft &amp;&amp; node.Right == qright) {
        return node.Value;
      }

      if (qright &lt;= node.LeftSon.Right) {
        return QueryValue(node.LeftSon, qleft, qright);
      } else if (qleft &gt;= node.LeftSon.Right) {
        return QueryValue(node.RightSon, qleft, qright);
      } else {
        return addFunc(QueryValue(node.LeftSon, qleft, node.LeftSon.Right),
          QueryValue(node.RightSon, node.RightSon.Left, qright));
      }
    }
  }
</code></pre>
]]></content>
    </entry>
</feed>