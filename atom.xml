<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jerilee.github.io</id>
    <title>Rong Sir的博客</title>
    <updated>2021-05-25T16:42:39.511Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jerilee.github.io"/>
    <link rel="self" href="https://jerilee.github.io/atom.xml"/>
    <subtitle>Phone: 17621996523
Mail: Rongerace@163.com</subtitle>
    <logo>https://jerilee.github.io/images/avatar.png</logo>
    <icon>https://jerilee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Rong Sir的博客</rights>
    <entry>
        <title type="html"><![CDATA[JAVA语言基础]]></title>
        <id>https://jerilee.github.io/post/java_language/</id>
        <link href="https://jerilee.github.io/post/java_language/">
        </link>
        <updated>2021-05-17T15:33:00.000Z</updated>
        <content type="html"><![CDATA[<p>一小时学会java系列</p>
<h2 id="java中的main函数"><strong>JAVA中的main函数</strong></h2>
<p>在C++中，进程开始于main函数。在JAVA中，进程开始于某个类的静态函数main，这里需要注意的是，main函数签名必须为规定的格式。</p>
<p>在C++中的实现方式</p>
<pre><code class="language-C++">int main(){
    std::cout &lt;&lt; &quot;Hello World!\n&quot;;
}
</code></pre>
<p>在JAVA中的实现方式</p>
<pre><code class="language-JAVA">public class Main {
    public static void main(String[] args) {
        System.out.println(&quot;Hello World&quot;);
    }
}
</code></pre>
<h2 id="值类型和引用类型"><strong>值类型和引用类型</strong></h2>
<p>java中，仅有以下几种值类型，其他类型（包括自定义类型）都是引用类型。</p>
<pre><code class="language-JAVA">int a = 1;
long b  = 2;
short c = 3;
char d = 4;
double e = 5.0;
float f = 6.0f;
char g = 0;
boolean h = false; 
</code></pre>
<h2 id="java中的基础数据结构"><strong>JAVA中的基础数据结构</strong></h2>
<p>C++的变长数组vector，对应java中的ArrayList</p>
<p>C++的vector使用</p>
<pre><code class="language-C++">std::vector&lt;int&gt; list;
list.push_back(1);
int temp = list[0];
int size = list.size();
</code></pre>
<p>JAVA的使用</p>
<pre><code class="language-JAVA">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
//向数组中添加
list.add(1);
//获取数组中index为0的元素
Integer temp = list.get(0);
//获得数组长度
int length = list.size();
</code></pre>
<p>C++和JAVA的数据结构对照表</p>
<table>
<thead>
<tr>
<th style="text-align:left">C++</th>
<th style="text-align:left">JAVA</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">vector</td>
<td style="text-align:left">ArrayList</td>
<td style="text-align:left">变长数组</td>
</tr>
<tr>
<td style="text-align:left">list</td>
<td style="text-align:left">LinkedList</td>
<td style="text-align:left">链表</td>
</tr>
<tr>
<td style="text-align:left">unordered_map</td>
<td style="text-align:left">HashMap</td>
<td style="text-align:left">哈希字典</td>
</tr>
<tr>
<td style="text-align:left">map</td>
<td style="text-align:left">TreeMap</td>
<td style="text-align:left">有序字典</td>
</tr>
<tr>
<td style="text-align:left">unordered_set</td>
<td style="text-align:left">HashSet</td>
<td style="text-align:left">哈希集合</td>
</tr>
<tr>
<td style="text-align:left">set</td>
<td style="text-align:left">TreeSet</td>
<td style="text-align:left">有序集合</td>
</tr>
</tbody>
</table>
<p>JAVA示例</p>
<pre><code class="language-JAVA">LinkedList&lt;Integer&gt; linkList = new LinkedList&lt;&gt;();
HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();
HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();
TreeMap&lt;Integer,Integer&gt; map = new TreeMap&lt;&gt;();
TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
</code></pre>
<p>JAVA有一个特点，泛型所有的实例化类型，均为引用类型，所以每一个值类型都有引用类型相对应，例如int对应Integer，boolean对应Boolean。<br>
在C++中，因为不同的类型创建对象占用不同大小的内存空间，每一个泛型的实例化，都会生成一份代码。而JAVA中所有类型均继承于Object，所以泛型实例化代码仅有一份。</p>
<p>这里需要注意的是，Java中所有表示下标的类型，均为值类型int，而不是引用类型Integer，例如Java库中ArrayList的remove函数如下，很巧妙的避免了ArrayList<Integer>在删除元素的时候调用函数出现错误。这也产生了另外一个问题，java数组的最大长度为int上限，很容易因数组长度超过最大长度而异常。</p>
<pre><code class="language-JAVA">//Removes the element at the specified position in this list
public E remove(int index) {
}
//Removes the first occurrence of the specified element from this list, if it is present
public boolean remove(Object o) {
}
</code></pre>
<h2 id="java的for"><strong>JAVA的for</strong></h2>
<p>Java提供了两种for循环的方式，和C++相同，也拥有相同的关键字continue和break</p>
<pre><code class="language-JAVA">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
for(int index = 0; index &lt; list.size();++index) {
    Integer value = list.get(index);
    break;
}

for(Integer integer: list) {
    continue;
}
</code></pre>
<h2 id="java的委托"><strong>JAVA的委托</strong></h2>
<p>类似于C++中的 std::function<T>，在JAVA中也存在泛型委托，当然在JAVA中没有委托的概念，它只是一个接口</p>
<p>例如，Test::print为一个静态函数，它的函数签名是一个Integer的入参，void类型的返回值。</p>
<pre><code class="language-JAVA">public class Test {
    public static void print(Integer p) {
        System.out.println(p);
    }
}
</code></pre>
<p>在代码中可以定义一个委托绑定这个函数，这个委托调用的时候，即调用这个函数。<br>
类似于C++的std::function&lt;void(int)&gt;，<br>
Consumer<T>即为单入参，无返回值的委托类型</p>
<pre><code class="language-JAVA">Consumer&lt;Integer&gt; func = Test::print;
Integer x = 5;
func.accept(x);
</code></pre>
<p>类似于C++的std::function&lt;int(int)&gt;, 单个入参，有返回值的情况，在java中使用Function&lt;T, TResult&gt;</p>
<pre><code class="language-JAVA">public class Test {
    public static Integer calculate(Integer x) {
        if(x &gt; 0) return x - 1;
        else return x + 1;
    }

    public static void main(String[] args) {
        Function&lt;Integer,Integer&gt; func3 = Test::calculate;
    }
}
</code></pre>
<p>类似于C++的std::function&lt;int(void)&gt;，没有入参，有返回值，使用Supplier<T></p>
<pre><code class="language-JAVA">public class Test {
    public static Integer x = 314;
    public static Integer calculate() {
        return (x &lt;&lt;= 17) ^ (x &gt;&gt;= 15) ^ (x &lt;&lt;= 8);
    }

    public static void main(String[] args) {
        Supplier&lt;Integer&gt; func3 = Test::calculate;
    }
}
</code></pre>
<p>类似于C++的std::function&lt;bool(int, int)&gt;，两个入参，有返回值，使用BiFunction&lt;T1, T2, TR&gt;</p>
<pre><code class="language-JAVA">public class Test {
    public static Boolean comp(Integer x, Integer y) {
        return x &lt; y;
    }

    public static void main(String[] args) {
        BiFunction&lt;Integer, Integer, Boolean&gt; func3 = Test::comp;
    }
}
</code></pre>
<p>和C++/C#中相同，在JAVA中，委托类型也可以自定义，以BiFunction&lt;T, U, R&gt;为例，它是一个接口，只要实例化时，实现这个apply的函数就可以了。后面还添加了一个语法糖，方便程序员串接委托。</p>
<pre><code class="language-JAVA">@FunctionalInterface
public interface BiFunction&lt;T, U, R&gt; {
    R apply(T t, U u);

    default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
        Objects.requireNonNull(after);
        return (T t, U u) -&gt; after.apply(apply(t, u));
    }
}
</code></pre>
<h2 id="java的lamda表达式"><strong>JAVA的lamda表达式</strong></h2>
<p>类似于C++中的lamda表达式，在JAVA中也存在lamda表达式<br>
格式:</p>
<pre><code class="language-JAVA">    (参数列表) -&gt; { 
        函数主体;
        return 返回值;
    };
</code></pre>
<p>当参数列表只有一个参数时，小括号可以省略；当函数主体只包含一行返回值时，函数主体括号可以省略。<br>
例如：</p>
<pre><code class="language-JAVA">Function&lt;Integer,Integer&gt; func10 = (x) -&gt; x+ 1;
Consumer&lt;Integer&gt; func11 = x -&gt; {};
BiFunction&lt;Integer,Integer, Boolean&gt; func12 = (x, y) -&gt; x &lt; y;
BiFunction&lt;Integer,Integer, Boolean&gt; func13 = (x, y) -&gt; {
    int z = x * y;
    return z &lt; x + y;
};
</code></pre>
<h2 id="java的stream"><strong>JAVA的Stream</strong></h2>
<p>类似于C#的linq表达式，简单地讲就是语法糖，便于JAVA程序员书写更简洁代码。</p>
<p>filter方法，在集合中筛选出满足条件的元素。<br>
例如，在一个List<Integer>中筛选出所有大于0的元素，把筛选出的元素生成新的List。</p>
<pre><code class="language-JAVA">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
 //找出List中所有大于0的元素，
List&lt;Integer&gt; list2 = list.stream().filter(i -&gt; i &gt; 0).collect(Collectors.toList());
</code></pre>
<p>stream函数定义在Collection<E>中，而List<E> 继承了Collection<E>的stream函数，这个函数的返回值是一个Stream<E>对象。</p>
<pre><code class="language-JAVA">//class Collection&lt;E&gt; 
default Stream&lt;E&gt; stream() {
    return StreamSupport.stream(spliterator(), false);
}
</code></pre>
<p>很显然，可以猜测出filter的参数是Function&lt;T, TResult&gt;类型，实际上并不完全正确，下面是库定义，这个Predicate&lt;? super T&gt; 的意思是，泛型的模板类型可以是T的任意一个基类，当predicate调用时，传入的参数需要是T的派生类。<br>
接口Predicate<T> 实际上是接口Function&lt;T, Boolean&gt; 的一个特例，又添加了几个函数定义。</p>
<pre><code class="language-JAVA">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);
</code></pre>
<p>map方法，集合转换为另一种类集合<br>
例如将Integer类型集合转换为String集合</p>
<pre><code class="language-JAVA">List&lt;String&gt; list3 = list.stream().map(i -&gt; i.toString()).collect(Collectors.toList());
</code></pre>
<p>stream的其他常用方法：</p>
<pre><code class="language-JAVA">    anyMatch     //任何一个满足条件，即为true
    noneMatch  //没有一个满足条件，即为true
    allMatch       //都满足条件，即为true
    findFirst()     //获得第一个
</code></pre>
<h2 id="java的注解"><strong>JAVA的注解</strong></h2>
<p>JAVA的注解用@标识，例如上文的BiFunction定义，@FunctionalInterface就标识了该接口为函数接口</p>
<pre><code class="language-JAVA">@FunctionalInterface
public interface BiFunction&lt;T, U, R&gt; {
    R apply(T t, U u);

    default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
        Objects.requireNonNull(after);
        return (T t, U u) -&gt; after.apply(apply(t, u));
    }
}
</code></pre>
<p>注解有三种类型，由枚举RetentionPolicy定义，分别是<br>
SOURCE：在原文件中有效，被编译器丢弃<br>
CLASS：在class文件有效，可能会被虚拟机忽略<br>
RUNTIME：在运行时有效</p>
<p>注解定义时也比较简单，即空接口，在interface前面加@</p>
<pre><code class="language-JAVA">public @interface FunctionalInterface {}
</code></pre>
<h2 id="java的-内部类-和内部静态类"><strong>JAVA的 内部类 和内部静态类</strong></h2>
<h2 id="java的匿名类">JAVA的匿名类</h2>
<h2 id="java的局部内部类">JAVA的局部内部类</h2>
<h2 id="java">JAVA</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[语言特性总结(目录)]]></title>
        <id>https://jerilee.github.io/post/languageFeature/</id>
        <link href="https://jerilee.github.io/post/languageFeature/">
        </link>
        <updated>2020-09-21T14:39:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="c语言总结"><strong>C++语言总结</strong></h2>
<h4 id="c11-language-feature"><a href="https://jerilee.github.io/post/c11-language-feature/">C++11 language feature</a></h4>
<h4 id="c11右值引用"><a href="https://jerilee.github.io/post/cpp_rvalue/">C++11右值引用</a></h4>
<h4 id="cprime-plus-笔记"><a href="https://jerilee.github.io/post/c-prime-plus-simple/">《C++Prime Plus 笔记》</a></h4>
<h2 id="c语言总结-2"><strong>C#语言总结</strong></h2>
<h4 id="c90新语法"><a href="https://jerilee.github.io/post/c_sharp9/">C#9.0新语法</a></h4>
<h4 id="csharp基础笔记"><a href="https://jerilee.github.io/post/cs_write1/">CSharp基础笔记</a></h4>
<p><strong>---------------------------------------------------------</strong></p>
<h2 id="我的c代码库"><strong>我的C++代码库</strong></h2>
<h2 id="我的c代码库-2"><strong>我的C#代码库</strong></h2>
<h4 id="no-name"><a href="https://jerilee.github.io/post/my_cs_library/">no name</a></h4>
<h4 id="敏感词匹配"><a href="https://jerilee.github.io/post/cs_sensitive_words/">敏感词匹配</a></h4>
<p><strong>---------------------------------------------------------</strong></p>
<h2 id="未整理的部分"><strong>未整理的部分</strong></h2>
<h3 id="未整理的c笔记2"><a href="https://jerilee.github.io/post/c-bi-ji-er/">未整理的C++笔记2</a></h3>
<h3 id="c笔记1"><a href="https://jerilee.github.io/post/wo-de-cbi-ji/">C++笔记1</a></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11的右值引用和左值引用]]></title>
        <id>https://jerilee.github.io/post/cpp_rvalue/</id>
        <link href="https://jerilee.github.io/post/cpp_rvalue/">
        </link>
        <updated>2020-09-21T14:30:38.000Z</updated>
        <content type="html"><![CDATA[<p><strong>关于右值引用 和左值引用的详解</strong></p>
<h3 id="引用规则">引用规则</h3>
<p>1.对于class Person模板匹配的时候，下列三种是左值引用<br>
Person&amp;&amp; &amp; 则转换为Person&amp;<br>
Person&amp; &amp;&amp; 则转换为Person&amp;<br>
Person&amp; &amp;  则转换为Person&amp;<br>
只有以下情况，才会是右值引用<br>
Person&amp;&amp; &amp;&amp; 则转换为Person&amp;&amp;</p>
<p>例如对于以下代码</p>
<pre><code>template&lt;typename T&gt; 
void func(T&amp;&amp;);

int i = 3;
func(i)  //T为int&amp;  所以模板实例化为int&amp;
func(2)  //T为int&amp;&amp; 所以模板实例化为int&amp;&amp;
</code></pre>
<p>很显然，这种情况下，模板会实例化两份</p>
<p>2.static_cast可以将一个左值转换为右值，该代码只会在编译器检查，实际上生成的二进制没有多1byte</p>
<h3 id="关于stdmove">关于std::move</h3>
<pre><code>// FUNCTION TEMPLATE move
template &lt;class _Ty&gt;
_NODISCARD constexpr remove_reference_t&lt;_Ty&gt;&amp;&amp; move(_Ty&amp;&amp; _Arg) noexcept { // forward _Arg as movable
    return static_cast&lt;remove_reference_t&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);
}
</code></pre>
<p>很明显，这个代码把任何引用转换为右值引用</p>
<pre><code>// FUNCTION TEMPLATE forward
template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty&amp;&amp; forward(
    remove_reference_t&lt;_Ty&gt;&amp; _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
    return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);
}

template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp;&amp; _Arg) noexcept { // forward an rvalue as an rvalue
    static_assert(!is_lvalue_reference_v&lt;_Ty&gt;, &quot;bad forward call&quot;);
    return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);
}
</code></pre>
<p>而std::forward 可以把左值转右值/左值， 或者把右值转右值</p>
<h3 id="举个例子">举个例子</h3>
<pre><code>
struct Person {
  int n = 0;
  Person() {
    cout &lt;&lt; &quot;默认构造 &quot; &lt;&lt; (void*)(&amp;n) &lt;&lt; endl;
  }
  Person(const Person&amp; a) {
    cout &lt;&lt; &quot;拷贝构造 &quot; &lt;&lt; (void*)(&amp;n) &lt;&lt; endl;
    cout &lt;&lt; &quot;from &quot; &lt;&lt; (void*)(&amp;a.n) &lt;&lt; endl;
  }
  Person(Person&amp;&amp; a) noexcept {
    cout &lt;&lt; &quot;移动构造 &quot; &lt;&lt; (void*)(&amp;n) &lt;&lt; endl;
    cout &lt;&lt; &quot;from &quot; &lt;&lt; (void*)(&amp;a.n) &lt;&lt; endl;
  }
  Person operator + (const Person&amp; b)const {
    cout &lt;&lt; &quot;操作 +&quot; &lt;&lt; endl;
    Person res;
    res.n = b.n + n;
    return res;
  }
  Person&amp; operator = (Person&amp;&amp; b) noexcept {
    cout &lt;&lt; &quot;移动赋值 &quot; &lt;&lt; (void*)(&amp;n) &lt;&lt; endl;
    cout &lt;&lt; &quot;from &quot; &lt;&lt; (void*)(&amp;b.n) &lt;&lt; endl;
    n = b.n;
    return *this;
  }

  Person&amp; operator = (const Person&amp; b) noexcept {
    cout &lt;&lt; &quot;拷贝赋值 &quot; &lt;&lt; (void*)(&amp;n) &lt;&lt; endl;
    cout &lt;&lt; &quot;from &quot; &lt;&lt; (void*)(&amp;b.n) &lt;&lt; endl;
    n = b.n;
    return *this;
  }

  ~Person() {
    cout &lt;&lt; &quot;析构 &quot; &lt;&lt; (void*)(&amp;n) &lt;&lt; endl;
  }
};


template&lt;typename T&gt;
void Dfs(T&amp;&amp; a, int cnt = 1) {
  a.n = 10086;
  static int count = 0;
  cout &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; (void*)(&amp;a.n) &lt;&lt; &quot; count &quot; &lt;&lt; &amp;count &lt;&lt; endl;
  if (cnt == 5) return;
  Dfs(std::forward&lt;T&amp;&amp;&gt;(a), cnt + 1); //很明显这里的a是左值，所以将他转为被他引用的类型
  //Dfs(a, cnt + 1);
}

int main(){
  Person a;
  Dfs(std::move(a)); // T = Person&amp;&amp;
  Dfs(a);            // T = Person&amp;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 language feature]]></title>
        <id>https://jerilee.github.io/post/c11-language-feature/</id>
        <link href="https://jerilee.github.io/post/c11-language-feature/">
        </link>
        <updated>2020-09-21T14:28:59.000Z</updated>
        <content type="html"><![CDATA[<p><strong>本文总结一下C++11语言特性</strong><br>
<strong>备注：关于详细的右值引用and左值引用由下一篇博客详细解释</strong></p>
<h2 id="c11-language-feature">C++11 language feature</h2>
<h3 id="18132">18.1.3.2</h3>
<p>decltype(x) y;<br>
将y定义为x类型</p>
<h3 id="18133-返回类型后置">18.1.3.3 返回类型后置</h3>
<p>auto f2(double, int) -&gt; double;<br>
auto f2(T t, U u) -&gt; decltype(T*U){</p>
<p>}</p>
<p>这里解决的问题是，在编译器遇到eff的参数列表前，T和U还不在作用域内，因此必须在参数列表后使用decltype</p>
<h3 id="18134-模板别名">18.1.3.4 模板别名</h3>
<p>using=<br>
和typename的区别在于，可以在编译时的模板初始化</p>
<pre><code>template&lt;typename T&gt;
using arr12 = std::array&lt;T, 12&gt;;
</code></pre>
<h3 id="1814-智能指针">18.1.4 智能指针</h3>
<p>新增unique_ptr, shared_ptr, weak_ptr<br>
详情，参考第16章</p>
<h3 id="1815-异常语法">18.1.5 异常语法</h3>
<p>old:</p>
<pre><code>void f501(int) throw(bad_dog);
void f733(long long) throw();
</code></pre>
<p>new</p>
<pre><code>void f875(short, short) noexcept;
</code></pre>
<h3 id="18171-显示转换">18.1.7.1 显示转换</h3>
<p>禁止单参数构造函数导致的隐式转换</p>
<pre><code>class A{
  explicit A(double);
  explicit operator double() const;
  operator int() const;
}

A b;
int n = b;    //allowed
double x = b; // not allowed
x = double(b);// allowed
</code></pre>
<h3 id="18182-新增容器">18.1.8.2 新增容器</h3>
<p>forward_list<br>
unordered_map<br>
unordered_multimap<br>
unordered_set<br>
unordered_multiset<br>
array</p>
<h3 id="1819-右值引用">18.1.9 右值引用</h3>
<p>...</p>
<h3 id="182-移动语义">18.2 移动语义</h3>
<p>...<br>
移动构造<br>
移动赋值</p>
<h3 id="1831">18.3.1</h3>
<p><strong>备注：可是我不明白，移动构造也是会构造的啊，除了托管堆内存，对于栈内存有什么意义呢。我需要一个办法托管栈内存，可能对于C++的退栈机制，这个想法不可行。</strong></p>
<pre><code>Person p1;
Person p11;
Person p2 = (p1 + p1); // VC++/Debug中，默认构造，移动构造。           VC++/Release中，默认构造
p11 = (p1 + p1);       // VC++/Debug中，默认构造，移动构造，移动赋值。 VC++/Release中，默认构造，移动赋值
</code></pre>
<h3 id="1832-默认方法和禁用方法">18.3.2 默认方法和禁用方法</h3>
<p>...</p>
<pre><code>= delete;   //禁用函数
= default;  //默认
</code></pre>
<h3 id="1834-委托构造函数">18.3.4 委托构造函数</h3>
<p>using Studeng::Person;<br>
继承构造函数<br>
<strong>备注：这tm会造成很多BUG，还不知道有什么用</strong></p>
<h3 id="1835-管理虚方法">18.3.5 管理虚方法</h3>
<pre><code>virtual void f(char* ch) const override {}
virtual void f(char* ch) const final {}
</code></pre>
<h3 id="184-lamda表达式">18.4 lamda表达式</h3>
<p>基础问题，略过</p>
<h3 id="185-包装器">18.5 包装器</h3>
<p>std::function<br>
便于泛型实例化，避免实例化很多次</p>
<p>例如：<br>
对于泛型函数</p>
<pre><code>template&lt;typename F&gt;
void use_f(F func) {
  static int count = 0;
  cout &lt;&lt; (&amp;count) &lt;&lt; endl;
}
</code></pre>
<p>调用函数</p>
<pre><code>use_f(my_add);                //1泛型实例
use_f(my_mul);                //1泛型实例
use_f(Fake1(2));              //2泛型实例
use_f(Fake1(4));              //2泛型实例
use_f(Fake2(8));              //3泛型实例
use_f(Fake2(16));             //3泛型实例
use_f([](double x) -&gt;double {return x + 2;}); //4泛型实例
use_f([](double x) -&gt;double {return x + 2;}); //5泛型实例
</code></pre>
<p>实例化函数和仿函数</p>
<pre><code>double my_add(double x) {
  return x + x;
}

double my_mul(double x) {
  return x * 2;
}
struct Fake1 {
  int n_;
  Fake1(int n) :n_(n) {}
  bool operator()(int x) {
    return x + n_;
  }
};
struct Fake2 {
  int n_;
  Fake2(int n) :n_(n) {}
  bool operator()(int x) {
    return x + n_;
  }
};
</code></pre>
<p>** 解决办法：把所有函数包装成std::function&lt;double(double)&gt; 实例化即可改为一次<br>
** 解决办法2：void use_f(T t, std::function&lt;T(T)&gt; func);</p>
<h3 id="186-可变参数模板">18.6 可变参数模板</h3>
<pre><code>template&lt;typename T&gt;
void show_list(T&amp;&amp; value) {
  //static int count = 0;
  //cout &lt;&lt; &quot;show one count &quot; &lt;&lt; &amp;count &lt;&lt; endl;
  cout &lt;&lt; value &lt;&lt; endl;
}

template&lt;typename T, typename... Args&gt;
void show_list(T&amp;&amp; value, Args&amp;&amp;... args) {
  //static int count = 0;
  //cout &lt;&lt; &quot;show list count &quot; &lt;&lt; &amp;count &lt;&lt; endl;
  cout &lt;&lt; value&lt;&lt; &quot; &quot;;
  show_list(args...);
}
</code></pre>
<h3 id="1871-并行编程">18.7.1 并行编程</h3>
<p>???</p>
<h3 id="1873">18.7.3</h3>
<p>alignof(Person) 查看字节对齐</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#9.0 新内容]]></title>
        <id>https://jerilee.github.io/post/c_sharp9/</id>
        <link href="https://jerilee.github.io/post/c_sharp9/">
        </link>
        <updated>2020-09-21T14:27:13.000Z</updated>
        <content type="html"><![CDATA[<p><strong>由于2020年9月还未发布正式版C# 9.0 所以本文内容暂时不全，后续会逐步完善</strong></p>
<h2 id="c-90-language-feature">C# 9.0 language feature</h2>
<h3 id="函数重写可以使用派生类返回值">函数重写可以使用派生类返回值</h3>
<pre><code class="language-C#">public class Food { }
public class Meat : Food { }
public class Poke : Meat { }
public abstract class Animal {
  public abstract Food GetFood();
}

public class Tiger : Animal{
  public override Meat GetFood(){
    throw new NotImplementedException();
  }
}

public class BigTiger : Tiger{
  public override Poke GetFood(){
    throw new NotImplementedException();
  }
}
</code></pre>
<h3 id="操作符-和">操作符 ?? 和 ?:</h3>
<pre><code>Person person = student ?? customer; // 共享基类，截止16.8.0Preview 3.0版本，还未实现该功能
int? result = b ? 0 : null; // 可null的值类型
</code></pre>
<h3 id="new操作符省略类型">new操作符省略类型</h3>
<pre><code>Point p = new (3, 5);
</code></pre>
<h3 id="switch匹配">Switch匹配</h3>
<p>传统代码</p>
<pre><code>public static decimal CalculateToll(object vehicle) =&gt;
    vehicle switch {
       ...
       
        DeliveryTruck t when t.GrossWeightClass &gt; 5000 =&gt; 10.00m + 5.00m,
        DeliveryTruck t when t.GrossWeightClass &lt; 3000 =&gt; 10.00m - 2.00m,
        DeliveryTruck _ =&gt; 10.00m,

        _ =&gt; throw new ArgumentException(&quot;Not a known vehicle type&quot;, nameof(vehicle))
    };
</code></pre>
<p>对于</p>
<pre><code>DeliveryTruck _ =&gt; 10.00m,
</code></pre>
<p>可以省略为</p>
<pre><code>DeliveryTruck =&gt; 10.00m,
</code></pre>
<p>新的书写方式</p>
<pre><code>DeliveryTruck t when t.GrossWeightClass switch {
    &gt; 5000 =&gt; 10.00m + 5.00m,
    &lt; 3000 =&gt; 10.00m - 2.00m,
    _ =&gt; 10.00m,
},
</code></pre>
<p>加入新的or and not</p>
<pre><code>&gt;= 3000 and &lt;= 5000 =&gt; 10.00m,
</code></pre>
<p>判断是否为空</p>
<pre><code>not null =&gt; xxx,
null =&gt; xxx,
</code></pre>
<p>另外 对于语句</p>
<pre><code>if (!(e is Customer)) { ... }
</code></pre>
<p>可以用新的方式书写</p>
<pre><code>if (e is not Customer) { ... }
</code></pre>
<h3 id="顶级语法">顶级语法</h3>
<pre><code>using System;

Console.WriteLine(&quot;Hello World!&quot;);
</code></pre>
<h3 id="比较相等">比较相等</h3>
<p>问题：Equal 处理基类和派生类，会采用不同的重写<br>
新的函数：EqualityContract</p>
<h3 id="record标识符-和-with标识符">Record标识符 和 with标识符</h3>
<pre><code>public record A(int Id,string Name);
public static void main() {
  A a = new A(1, &quot;&quot;);
  A b = a with { Id = 2 };
  Console.WriteLine(a.Id);
  Console.WriteLine(b.Id);
}
</code></pre>
<h3 id="属性标记init">属性标记init</h3>
<p>对于init标记的属性，只能在构造和初始化的时候修改。</p>
<pre><code>public class Person
{
  public int Id { get; init; } = 2;
  public string Name;
  public Person(int a, string b)
  {
    Id = a;
    Name = b;
  }
}
</code></pre>
<h3 id="反构造">反构造</h3>
<pre><code>A a = new A(1, &quot;&quot;); //构造
var (id, name) = a; //反向构造
</code></pre>
<p>record或class或struct都可以反向构造</p>
<pre><code class="language-重写反构造">public record A{
  public int Id;
  public string Name;
  public A(int id, string name)
    =&gt; (Id, Name) = (id, name);
  public void Deconstruct(out int id, out string name)
    =&gt; (id, name) = (Id, Name);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ Prime Plus简述]]></title>
        <id>https://jerilee.github.io/post/c-prime-plus-simple/</id>
        <link href="https://jerilee.github.io/post/c-prime-plus-simple/">
        </link>
        <updated>2020-08-28T16:41:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第三章处理数据">第三章处理数据</h2>
<h3 id="整形">整形</h3>
<pre><code class="language-C++">int x;
cout &lt;&lt; hex &lt;&lt; x &lt;&lt;endl;  // 16进制
cout &lt;&lt; oct &lt;&lt; x &lt;&lt;endl;  // 8进制
</code></pre>
<p>CHAR_BIT<br>
CHAR_MAX<br>
CHAR_MIN</p>
<p>SCHAR_MAX<br>
SCHAR_MIN<br>
UCHAR_MAX</p>
<p>SHRT_MAX<br>
SHRT_MIN<br>
USHRT_NAX</p>
<p>INT_MAX<br>
INT_MIN<br>
UNIT_MAX</p>
<p>LONG_MAX<br>
LONG_MIN<br>
ULONG_MAX</p>
<p>LLONG_MAX<br>
LLONG_MIN<br>
ULLONG_MAX</p>
<h3 id="cin-cout">cin cout</h3>
<pre><code>cin.put(int x); //输出一个字符
</code></pre>
<h3 id="char">char</h3>
<pre><code>//Ctrl + Z
//ASCALL 26
char c = 032 = 0x1a = '\032';
string s = &quot;65\x41\n&quot;;
</code></pre>
<h3 id="wchar_t">wchar_t</h3>
<h3 id="char32_t-char16_t">char32_t char16_t</h3>
<p>C++11新增，内置整形，随系统而改变</p>
<pre><code>char16_t ch1 = u'q';
char32_t ch2 = U'\U0000222B';
const char16_t s[4] = u&quot;ABC&quot;;
const char32_t s2[4] = U&quot;ABC&quot;;
</code></pre>
<h3 id="const-常量">const 常量</h3>
<p>const常量 在C++ 和C中作用域不同（详见第九章）<br>
const常量在C++中可以用来声明数组长度</p>
<h3 id="浮点数">浮点数</h3>
<pre><code>//打印6位小数 更多详情第17章
cout.setf(ios_base::fixed, ios_base::floatfield);
cout &lt;&lt; 3.5 &lt;&lt; endl;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 笔记（二）]]></title>
        <id>https://jerilee.github.io/post/c-bi-ji-er/</id>
        <link href="https://jerilee.github.io/post/c-bi-ji-er/">
        </link>
        <updated>2020-08-24T14:16:02.000Z</updated>
        <content type="html"><![CDATA[<p>以下内容没有阅读过C++文档确认，可能存在错误。</p>
<h2 id="plament-new">plament new</h2>
<p>plament new 在指定内存地址上调用构造函数</p>
<pre><code class="language-C++">class T{ 
};

int main(){
  //申请一块堆内存
  void* ptr = malloc(sizeof(T));
  调用构造函数
  T* ptr2 = new(ptr) T(1,2,3,4);
  //申请一块栈内存
  T a[1000];
  调用构造函数
  ptr2 = new(a) T(1,2,3,4);
}
</code></pre>
<h2 id="未完成的部分">未完成的部分</h2>
<p>关于重载operate new，还有些没搞明白</p>
<pre><code class="language-C++">#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;

void* operator new (size_t t) {
  printf(&quot;Global operator new called\n&quot;);
  return malloc(t);
}

class T {
public:
  int a;
  int b;
  int c;
  long d;
  void Init(int a_, int b_, int c_, long d_) {
    a = a_, b = b_, c = c_, d = d_;
  }

  static void* operator new(size_t t, void*) {
    printf(&quot;operator new called 1\n&quot;);
    //return ::operator new(t);
    return malloc(t);
  }
  void* operator new(size_t t) {
    printf(&quot;operator new called 2\n&quot;);
    //return ::operator new(t);
    return malloc(t);
  }

  T(int a_, int b_, int c_, long d_) {
    a = a_, b = b_, c = c_, d = d_;
  }
  T() {}

  ~T() {}
};

int main() {
  //T* a = new T();
  void* raw = operator new(sizeof(T));
  cout &lt;&lt; &quot;oper&quot; &lt;&lt; endl;
  T* raw_t = static_cast&lt;T*&gt;(raw);
  raw_t -&gt; T::T(1,2,3,4);
  T* ptr = new(raw) T();
  raw_t-&gt;~T();
  raw_t-&gt;Init(1,2,3,4);

  return 0;
}


</code></pre>
<h2 id="输入输出">输入输出</h2>
<pre><code>char s[1024];
</code></pre>
<h3 id="scanf_s">scanf_s</h3>
<pre><code>scanf_s(&quot;%4s&quot;, s, 5);
printf(&quot;[%s]\n&quot;, s);
</code></pre>
<p>读取4个字符（可以不写）<br>
缓冲区大小为5（必须要写）</p>
<h3 id="cinget">cin.get()</h3>
<pre><code>cin.get(s, 5);
</code></pre>
<p>读取该行字符串，缓冲区大小为5，最多读取缓冲区大小减1个字符<br>
注意:该接口不能读取下一行，行尾返回空串</p>
<pre><code>char c;
c = cin.get();
</code></pre>
<p>读取一个字符，也会读取空白符类似于getchar()</p>
<h3 id="cins">cin&gt;&gt;s</h3>
<pre><code>cin&gt;&gt;s;
</code></pre>
<p>读取一个字符串，遇到空白符结束 类似于scanf(%s)</p>
<h3 id="cingetline">cin.getline()</h3>
<pre><code>cin.getline(s, maxn);
printf(&quot;[%s] %d\n&quot;, s, strlen(s));
</code></pre>
<p>读取一行，包括空白符，回车不会包含在内类似于 gets_s()</p>
<pre><code>cin.getline(s, maxn, 10);
</code></pre>
<p>cin.getline()有第三个参数，默认是Ascii[10]，可自定义</p>
<h3 id="getline">getline()</h3>
<pre><code>string str;
getline(cin, str);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排行榜代码模板(平衡树&线段树)]]></title>
        <id>https://jerilee.github.io/post/rank_by_avl_tree_segment_tree/</id>
        <link href="https://jerilee.github.io/post/rank_by_avl_tree_segment_tree/">
        </link>
        <updated>2020-08-04T13:10:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="排行榜代码模板">排行榜代码模板</h2>
<h2 id="基于平衡二叉树和线段树">基于平衡二叉树和线段树</h2>
<p>在完全平衡树上写一颗线段树</p>
<h3 id="实现逻辑">实现逻辑</h3>
<p>以后再写<br>
...<br>
...<br>
...</p>
<h3 id="c版本">C#版本</h3>
<p><strong>备注：代码是不完整版本</strong></p>
<pre><code class="language-C#">  /// &lt;summary&gt;
  /// AVLTree
  /// Author:  Jerilee
  /// Time:    2020-8-4 17:00
  /// Link :   jerilee.github.io
  /// &lt;/summary&gt;
  public class RankList&lt;T&gt; where T : IComparable&lt;T&gt; {
    class Node {
      public T value;
      public Node leftSon;
      public Node rightSon;
      public int height;

      public int LeftCount;
      public int RightCount;

      public Node(T v) {
        value = v;
        height = 1;
        leftSon = rightSon = default;
        LeftCount = RightCount = 0;
      }

      public void UpdateHeight() {
        height = Math.Max(leftSon?.height ?? 0, rightSon?.height ?? 0) + 1;
      }

      public void UpdateCount() {
        LeftCount = leftSon?.Count ?? 0;
        RightCount = rightSon?.Count ?? 0;
      }

      public int DisHeight =&gt; (leftSon?.height ?? 0) - (rightSon?.height ?? 0);
      public int Count =&gt; LeftCount + RightCount + 1;
    }

    private Node root;
    private Comparer&lt;T&gt; comparer;
    private int Count;
    public RankList() {
      comparer = Comparer&lt;T&gt;.Default;
      Count = 0;
    }

    public void Init(List&lt;T&gt; source) {
      foreach (var item in source) {
        Add(item);
      }
    }

    public List&lt;T&gt; ToList() {
      List&lt;T&gt; list = new List&lt;T&gt;();
      Dfs(root, list);
      return list;
    }

    private void Dfs(Node node, List&lt;T&gt; list) {
      if (node != null) {
        var l = node.leftSon != null ? node.leftSon.value : default;
        var r = node.rightSon != null ? node.rightSon.value : default;
        Console.WriteLine($&quot;Node father[{node.value}] Lson[{l}] rSon[{r}] H[{node.height}] C[{node.LeftCount}]&quot;);
        Dfs(node.leftSon, list);
        list.Add(node.value);
        Dfs(node.rightSon, list);
      }
    }

    private Node RotateR(Node node) {
      Node lson = node.leftSon;
      Node lsonRson = lson.rightSon;
      lson.rightSon = node;
      node.leftSon = lsonRson;
      node.UpdateHeight();
      lson.UpdateHeight();
      node.UpdateCount();
      lson.UpdateCount();
      return lson;
    }

    private Node RotateL(Node node) {
      Node rson = node.rightSon;
      Node rsonLson = rson.leftSon;
      rson.leftSon = node;
      node.rightSon = rsonLson;
      node.UpdateHeight();
      rson.UpdateHeight();
      node.UpdateCount();
      rson.UpdateCount();
      return rson;
    }

    private Node RotateLR(Node node) {
      node.leftSon = RotateL(node.leftSon);
      return RotateR(node);
    }

    private Node RotateRL(Node node) {
      node.rightSon = RotateR(node.rightSon);
      return RotateL(node);
    }

    private void CheckRotateR(ref Node node) {
      if (node.DisHeight &gt; 1) {
        int leftH = node.leftSon.leftSon?.height ?? 0;
        int rightH = node.leftSon.rightSon?.height ?? 0;
        node = leftH &gt;= rightH ? RotateR(node) : RotateLR(node);
      }
    }

    private void CheckRotateL(ref Node node) {
      if (node.DisHeight &lt; -1) {
        int leftH = node.rightSon.leftSon?.height ?? 0;
        int rightH = node.rightSon.rightSon?.height ?? 0;
        node = leftH &gt; rightH ? RotateRL(node) : RotateL(node);
      }
    }

    private Node Add(Node node, T val) {
      if (node == null) {
        node = new Node(val);
        ++Count;
      } else {
        int c = comparer.Compare(val, node.value);
        if (c &lt; 0) {
          node.leftSon = Add(node.leftSon, val);
          CheckRotateR(ref node);
        } else if (c &gt; 0) {
          node.rightSon = Add(node.rightSon, val);
          CheckRotateL(ref node);
        }
        node.UpdateHeight();
        node.UpdateCount();
      }
      return node;
    }

    public void Add(T item) {
      Console.WriteLine($&quot;Add Item {item}&quot;);
      root = Add(root, item);
      ToList();
    }

    public bool Remove(T item) {
       bool ret = Remove(ref root, item);
      if (ret) {
        --Count;
      }
      return ret;
    }

    private bool Remove(ref Node node, T item) {
      if (node != null) {
        int c = comparer.Compare(item, node.value);

        if (c == 0) {
          if (node.leftSon == null &amp;&amp; node.rightSon == null) {
            node = default;
          } else if (node.leftSon == null) {
            node = node.rightSon;
          } else if (node.rightSon == null) {
            node = node.leftSon;
          } else {
            Node lson = node.leftSon;
            while (lson.rightSon != null) {
              lson = lson.rightSon;
            }
            node.value = lson.value;
            Remove(ref node.leftSon, node.value);

            CheckRotateL(ref node);
            node.UpdateHeight();
            node.UpdateCount();
          }
          return true;
        } else if (c &lt; 0) {
          bool ret = Remove(ref node.leftSon, item);
          CheckRotateL(ref node);
          node.UpdateHeight();
          node.UpdateCount();
          return ret;
        } else {
          bool ret = Remove(ref node.rightSon, item);
          CheckRotateR(ref node);
          node.UpdateHeight();
          node.UpdateCount();
          return ret;
        }
      }
      return false;
    }

    public bool Change(T fromItem, T toItem) {
      if (Remove(fromItem)) {
        Add(toItem);
        return true;
      }
      return false;
    }
    /*
    public bool Contain(T item) {
      return Find(item, root) != null;
    }

    private Node Find(T item, Node node) {
      if (node != null) {
        int c = comparer.Compare(item, node.value);
        return c == 0 ? node : Find(item, c &lt; 0 ? node.leftSon : node.rightSon);
      }
      return null;
    }
    */
    public int GetRank(T item) {
      return GetRank(root, item);
    }

    private int GetRank(Node node, T item) {
      if(node != null) {
        int c = comparer.Compare(item, node.value);
        if (c == 0) {
          return node.LeftCount + 1;
        } else if (c &lt; 0) {
          return GetRank(node.leftSon, item);
        } else {
          int t = GetRank(node.rightSon, item);
          return t &lt; 0 ? t : t + node.LeftCount + 1;
        }
      }
      return -1;
    }

    public T GetValueByRank(int Rank) {
      if(Rank &gt; 0 &amp;&amp; Rank &lt;= Count) {
        return GetValueByRank(root, Rank);
      }
      return default;
    }

    private T GetValueByRank(Node node, int rank) {
      if(node != null) {
        if(rank == node.LeftCount + 1) {
          return node.value;
        }else if(rank &lt; node.LeftCount + 1) {
          return GetValueByRank(node.leftSon, rank);
        }else {
          return GetValueByRank(node.rightSon, rank - node.LeftCount - 1);
        }
      }
      return default;
    }
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构（完全二叉平衡树 AVL Tree）]]></title>
        <id>https://jerilee.github.io/post/avl_tree/</id>
        <link href="https://jerilee.github.io/post/avl_tree/">
        </link>
        <updated>2020-08-04T13:04:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础数据结构">基础数据结构</h1>
<p>@(数据结构)[完全平衡树|AVL Tree|数据结构]</p>
<hr>
<p>[TOC]</p>
<h2 id="完全平衡树-avltree"><strong>完全平衡树 AVLTree</strong></h2>
<h3 id="概念"><strong>概念</strong></h3>
<p>以后补充<br>
...<br>
...<br>
...</p>
<h3 id="code"><strong>Code</strong></h3>
<h4 id="c"><strong>C#</strong></h4>
<p><strong>Author:  Jerilee</strong><br>
<strong>Time: 最后修改日2020-8-4 20:00</strong><br>
<strong>AVLTree树</strong></p>
<pre><code class="language-C#">  /// &lt;summary&gt;
  /// AVLTree
  /// Author:  Jerilee
  /// Time:    2020-8-4 14:47
  /// Link :   jerilee.github.io
  /// &lt;/summary&gt;
  public class AVLTree&lt;T&gt; where T : IComparable&lt;T&gt; {
    class Node {
      public T value;
      public Node leftSon;
      public Node rightSon;
      public int height;
      public Node(T v) {
        value = v;
        height = 1;
        leftSon = default;
        rightSon = default;
      }

      public void UpdateHeight() {
        height = Math.Max(leftSon?.height ?? 0, rightSon?.height ?? 0) + 1;
      }

      public int DisHeight =&gt; (leftSon?.height ?? 0) - (rightSon?.height ?? 0);
    }

    private Node root;
    private Comparer&lt;T&gt; comparer;
    public AVLTree() {
      comparer = Comparer&lt;T&gt;.Default;
    }

    public void Init(List&lt;T&gt; source) {
      foreach (var item in source) {
        Add(item);
      }
    }

    public List&lt;T&gt; ToList() {
      List&lt;T&gt; list = new List&lt;T&gt;();
      Dfs(root, list);
      return list;
    }

    private void Dfs(Node node, List&lt;T&gt; list) {
      if (node != null) {
        var l = node.leftSon != null ? node.leftSon.value : default;
        var r = node.rightSon != null ? node.rightSon.value : default;
        //Console.WriteLine($&quot;Node father[{node.value}] Lson[{l}] rSon[{r}] H[{node.height}]&quot;);
        Dfs(node.leftSon, list);
        list.Add(node.value);
        Dfs(node.rightSon, list);
      }
    }

    private Node RotateR(Node node) {
      Node lson = node.leftSon;
      Node lsonRson = lson.rightSon;
      lson.rightSon = node;
      node.leftSon = lsonRson;
      node.UpdateHeight();
      lson.UpdateHeight();
      return lson;
    }

    private Node RotateL(Node node) {
      Node rson = node.rightSon;
      Node rsonLson = rson.leftSon;
      rson.leftSon = node;
      node.rightSon = rsonLson;
      node.UpdateHeight();
      rson.UpdateHeight();
      return rson;
    }

    private Node RotateLR(Node node) {
      node.leftSon = RotateL(node.leftSon);
      return RotateR(node);
    }

    private Node RotateRL(Node node) {
      node.rightSon = RotateR(node.rightSon);
      return RotateL(node);
    }

    private void CheckRotateR(ref Node node) {
      if (node.DisHeight &gt; 1) {
        int leftH = node.leftSon.leftSon?.height ?? 0;
        int rightH = node.leftSon.rightSon?.height ?? 0;
        node = leftH &gt;= rightH ? RotateR(node) : RotateLR(node);
      }
    }

    private void CheckRotateL(ref Node node) {
      if (node.DisHeight &lt; -1) {
        int leftH = node.rightSon.leftSon?.height ?? 0;
        int rightH = node.rightSon.rightSon?.height ?? 0;
        node = leftH &gt; rightH ? RotateRL(node) : RotateL(node);
      }
    }

    private Node Add(Node node, T val) {
      if (node == null) {
        node = new Node(val);
      } else {
        int c = comparer.Compare(val, node.value);
        if (c &lt; 0) {
          node.leftSon = Add(node.leftSon, val);
          CheckRotateR(ref node);
        } else if (c &gt; 0) {
          node.rightSon = Add(node.rightSon, val);
          CheckRotateL(ref node);
        }
        node.UpdateHeight();
      }
      return node;
    }

    public void Add(T item) {
      root = Add(root, item);
    }

    public bool Remove(T item) {
      return Remove(ref root, item);
    }

    private bool Remove(ref Node node, T item) {
      if (node != null) {
        int c = comparer.Compare(item, node.value);

        if (c == 0) {
          if(node.leftSon == null &amp;&amp; node.rightSon == null) {
            node = default;
          }else if(node.leftSon == null) {
            node = node.rightSon;
          }else if(node.rightSon == null) {
            node = node.leftSon;
          } else {
            Node lson = node.leftSon;
            while (lson.rightSon != null) {
              lson = lson.rightSon;
            }
            node.value = lson.value;
            Remove(ref node.leftSon, node.value);

            CheckRotateL(ref node);
            node.UpdateHeight();
          }
          return true;
        } else if (c &lt; 0) {
          bool ret = Remove(ref node.leftSon, item);
          CheckRotateL(ref node);
          node.UpdateHeight();
          return ret;
        } else {
          bool ret = Remove(ref node.rightSon, item);
          CheckRotateR(ref node);
          node.UpdateHeight();
          return ret;
        }
      }
      return false;
    }

    public bool Change(T fromItem, T toItem) {
      if (Remove(fromItem)) {
        Add(toItem);
        return true;
      }
      return false;
    }

    public bool Contain(T item) {
      return Find(item, root) != null;
    }

    private Node Find(T item, Node node) {
      if (node != null) {
        int c = comparer.Compare(item, node.value);
        return c == 0 ? node : Find(item, c &lt; 0 ? node.leftSon : node.rightSon);
      }
      return null;
    }
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构(二叉搜索树BinarySortTree)]]></title>
        <id>https://jerilee.github.io/post/binary_sort_tree/</id>
        <link href="https://jerilee.github.io/post/binary_sort_tree/">
        </link>
        <updated>2020-08-04T12:55:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础数据结构">基础数据结构</h1>
<p>@(数据结构)[二叉搜索树|BinarySortTree|数据结构]</p>
<hr>
<p>[TOC]</p>
<h2 id="二叉搜索树-bst"><strong>二叉搜索树 BST</strong></h2>
<h3 id="概念"><strong>概念</strong></h3>
<pre><code>      以后补充
</code></pre>
<h3 id="code"><strong>Code</strong></h3>
<h4 id="c"><strong>C#</strong></h4>
<p><strong>Author:  Jerilee</strong><br>
<strong>Time: 最后修改日2020-8-4</strong><br>
<strong>BST</strong></p>
<pre><code class="language-C#">  /// &lt;summary&gt;
  /// BinarySortTree
  /// Author:  Jerilee
  /// Time:    2020-8-3 10:24
  /// Link :   jerilee.github.io
  /// &lt;/summary&gt;
  public class BinarySortTree&lt;T&gt; where T : IComparable&lt;T&gt; {
    class Node {
      public T value;
      public Node leftSon;
      public Node rightSon;
      public Node(T v) {
        value = v;
        leftSon = default;
        rightSon = default;
      }
    }

    private Node root;

    public BinarySortTree() {
    }

    public void Init(List&lt;T&gt; source) {
      foreach (var item in source) {
        Add(item);
      }
    }

    public List&lt;T&gt; ToList() {
      List&lt;T&gt; list = new List&lt;T&gt;();
      Dfs(root, list);
      return list;
    }

    private void Dfs(Node node, List&lt;T&gt; list) {
      if (node != null) {
        Dfs(node.leftSon, list);
        list.Add(node.value);
        Dfs(node.rightSon, list);
      }
    }

    public bool Add(T item) {
      if (root == null) {
        root = new Node(item);
        return true;
      } else {
        Node node = root;
        var comparer = Comparer&lt;T&gt;.Default;
        while (true) {
          int c = comparer.Compare(item, node.value);
          if (c == 0) {
            return false;
          } else if (c &lt; 0) {
            if (node.leftSon != null) {
              node = node.leftSon;
            } else {
              node.leftSon = new Node(item);
              return true;
            }
          } else {
            if (node.rightSon != null) {
              node = node.rightSon;
            } else {
              node.rightSon = new Node(item);
              return true;
            }
          }
        }
      }
    }

    public bool Remove(T item) {
      return Remove(ref root, item);
    }

    private bool Remove(ref Node node, T item) {

      if (node != null) {
        var comparer = Comparer&lt;T&gt;.Default;
        int c = comparer.Compare(item, node.value);
        return c == 0 ? Delete(ref node) : Remove(ref c &lt; 0 ? ref node.leftSon : ref node.rightSon, item);
        // [1]
      }
      return false;
    }

    private bool Delete(ref Node node) {
      if (node.leftSon == null &amp;&amp; node.rightSon == null) {
        node = default;
      } else if (node.leftSon == null) {
        node = node.rightSon;
      } else if (node.rightSon == null) {
        node = node.leftSon;
      } else {
        var lson = node.leftSon;
        var last = node;
        while (lson.rightSon != null) {
          last = lson;
          lson = lson.rightSon;
        }

        node.value = lson.value;

        if (last == node) {
          last.leftSon = lson.leftSon;
        } else {
          last.rightSon = lson.leftSon;
        }
      }
      return true;
    }

    public bool Change(T fromItem, T toItem) {
      if (Remove(fromItem)) {
        Add(toItem);
        return true;
      }
      return false;
    }

    public bool Contain(T item) {
      return Find(item, root) != null;
    }

    private Node Find(T item, Node node) {
      if (node != null) {
        var comparer = Comparer&lt;T&gt;.Default;
        int c = comparer.Compare(item, node.value);
        return c == 0 ? node : Find(item, c &lt; 0 ? node.leftSon : node.rightSon);
      }
      return null;
    }
  }

  /* [1]
  if (c == 0) {
    return Delete(ref node);
  }else if(c &lt; 0) {
    return Remove(ref node.leftSon, item);
  } else {
    return Remove(ref node.rightSon, item);
  }
  */
</code></pre>
]]></content>
    </entry>
</feed>